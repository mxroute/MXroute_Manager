define(["angular","cjt/util/locale","cjt/util/parse","cjt/io/uapi-request","cjt/io/api","cjt/io/uapi","cjt/services/APIService","cjt/filters/qaSafeIDFilter"],function(angular,LOCALE,PARSE,UAPIREQUEST){"use strict";var app=angular.module("cpanel.versionControl.service",[]);app.value("PAGE",PAGE);app.factory("versionControlService",["$q","APIService","$filter","PAGE","$timeout","$rootScope",function($q,APIService,$filter,PAGE,$timeout,$rootScope){var VersionControlService=function(){};var repos=[];var fileManagerPath=PAGE.fileManagerURL;var gitWebPath=PAGE.gitwebURL;function parseHeadCommitInformation(repoInfo){var commitInfo={};commitInfo.lastUpdateSHA=LOCALE.maketext("Not available.");commitInfo.lastUpdateDate=LOCALE.maketext("Not available.");commitInfo.commitMessage=LOCALE.maketext("Not available.");commitInfo.author=LOCALE.maketext("Not available.");commitInfo.hasHeadInformation=false;if(typeof repoInfo.last_update!=="undefined"&&repoInfo.last_update){commitInfo.hasHeadInformation=true;if(typeof repoInfo.last_update.identifier!=="undefined"&&repoInfo.last_update.identifier){commitInfo.lastUpdateSHA=repoInfo.last_update.identifier}if(typeof repoInfo.last_update.date!=="undefined"&&repoInfo.last_update.date){commitInfo.lastUpdateDate=getHumanReadableTime(repoInfo.last_update.date)}if(typeof repoInfo.last_update.author!=="undefined"&&repoInfo.last_update.author){commitInfo.author=repoInfo.last_update.author}if(typeof repoInfo.last_update.message!=="undefined"&&repoInfo.last_update.message){commitInfo.commitMessage=repoInfo.last_update.message}}return commitInfo}function parseLastDeployedInformation(repoInfo){var deployedInfo={};deployedInfo.hasDeploymentInformation=false;deployedInfo.lastDeployedSHA=LOCALE.maketext("Not available.");deployedInfo.lastDeployedDate=LOCALE.maketext("Not available.");deployedInfo.lastDeployedCommitDate=LOCALE.maketext("Not available.");deployedInfo.lastDeployedCommitMessage=LOCALE.maketext("Not available.");deployedInfo.lastDeployedAuthor=LOCALE.maketext("Not available.");if(typeof repoInfo.last_deployment!=="undefined"&&repoInfo.last_deployment){deployedInfo.hasDeploymentInformation=true;if(typeof repoInfo.last_deployment.timestamps!=="undefined"&&typeof repoInfo.last_deployment.timestamps.succeeded!=="undefined"&&repoInfo.last_deployment.timestamps.succeeded){deployedInfo.lastDeployedDate=getHumanReadableTime(repoInfo.last_deployment.timestamps.succeeded);if(typeof repoInfo.last_deployment.repository_state!=="undefined"&&repoInfo.last_deployment.repository_state){if(typeof repoInfo.last_deployment.repository_state.identifier!=="undefined"&&repoInfo.last_deployment.repository_state.identifier){deployedInfo.lastDeployedSHA=repoInfo.last_deployment.repository_state.identifier}if(typeof repoInfo.last_deployment.repository_state.date!=="undefined"&&repoInfo.last_deployment.repository_state.date){deployedInfo.lastDeployedCommitDate=getHumanReadableTime(repoInfo.last_deployment.repository_state.date)}if(typeof repoInfo.last_deployment.repository_state.message!=="undefined"&&repoInfo.last_deployment.repository_state.message){deployedInfo.lastDeployedCommitMessage=repoInfo.last_deployment.repository_state.message}if(typeof repoInfo.last_deployment.repository_state.author!=="undefined"&&repoInfo.last_deployment.repository_state.author){deployedInfo.lastDeployedAuthor=repoInfo.last_deployment.repository_state.author}}}}return deployedInfo}function refineRepositoryInformation(repoInfo){if(repoInfo&&typeof repoInfo!=="undefined"){repoInfo.qaSafeSuffix=$filter("qaSafeID")(repoInfo.repository_root);if(fileManagerPath){repoInfo.fileManagerRedirectURL=fileManagerPath+encodeURIComponent(repoInfo.repository_root)}else{repoInfo.fileManagerRedirectURL=""}if(gitWebPath){var projectPath=repoInfo.repository_root.replace(/^\/+/g,"")+"/.git";repoInfo.gitWebURL=gitWebPath+encodeURIComponent(projectPath)}else{repoInfo.gitWebURL=""}repoInfo.hasRemote=typeof repoInfo.source_repository!=="undefined"&&repoInfo.source_repository;if(typeof repoInfo.clone_urls!=="undefined"&&repoInfo.clone_urls){repoInfo.cloneURL=repoInfo.clone_urls.read_write[0]||repoInfo.clone_urls.read_only[0]}repoInfo.activeBranch=LOCALE.maketext("Not available.");repoInfo.hasActiveBranch=false;if(typeof repoInfo.branch!=="undefined"&&repoInfo.branch){repoInfo.activeBranch=repoInfo.branch;repoInfo.hasActiveBranch=true}var commitInfo=parseHeadCommitInformation(repoInfo);repoInfo.lastUpdateSHA=commitInfo.lastUpdateSHA;repoInfo.lastUpdateDate=commitInfo.lastUpdateDate;repoInfo.commitMessage=commitInfo.commitMessage;repoInfo.author=commitInfo.author;repoInfo.hasHeadInformation=commitInfo.hasHeadInformation;var lastDeployedInfo=parseLastDeployedInformation(repoInfo);repoInfo.hasDeploymentInformation=lastDeployedInfo.hasDeploymentInformation;repoInfo.lastDeployedSHA=lastDeployedInfo.lastDeployedSHA;repoInfo.lastDeployedDate=lastDeployedInfo.lastDeployedDate;repoInfo.lastDeployedCommitDate=lastDeployedInfo.lastDeployedCommitDate;repoInfo.lastDeployedCommitMessage=lastDeployedInfo.lastDeployedCommitMessage;repoInfo.lastDeployedAuthor=lastDeployedInfo.lastDeployedAuthor;repoInfo.deployable=PARSE.parsePerlBoolean(repoInfo.deployable);repoInfo.cloneInProgress=false;repoInfo.deployInProgress=false;if(typeof repoInfo.tasks!=="undefined"&&repoInfo.tasks&&repoInfo.tasks.length>0){for(var i=0,len=repoInfo.tasks.length;i<len;i++){if(repoInfo.tasks[i].action==="create"){repoInfo.cloneInProgress=true;repoInfo.cloneTaskID=repoInfo.tasks[i].id}if(repoInfo.tasks[i].action==="deploy"){repoInfo.deployInProgress=true}}}}return repoInfo}function getHumanReadableTime(epochTime){return LOCALE.local_datetime(epochTime,"datetime_format_medium")}function prepareList(data){var list=[];if(typeof data!=="undefined"&&data!==null){for(var i=0,len=data.length;i<len;i++){var value=refineRepositoryInformation(data[i]);list.push(value)}}return list}function getRepositoryIndex(reposList,path){var index=null;if(typeof reposList!==undefined&&reposList){for(var repoIndex=0,repoLength=reposList.length;repoIndex<repoLength;repoIndex++){if(reposList[repoIndex].repository_root===path){index=repoIndex;break}}}return index}function copyTextToClipboard(text){var textArea=document.createElement("textarea");textArea.value=text;document.body.appendChild(textArea);textArea.select();try{document.execCommand("copy")}catch(e){throw new Error(LOCALE.maketext("You cannot copy the “[_1]” clone [output,acronym,URL,Uniform Resource Locator] to the clipboard.",text))}document.body.removeChild(textArea)}repos=prepareList(PAGE.repos);VersionControlService.prototype=new APIService;angular.extend(VersionControlService.prototype,{getRepositoryList:function(){return repos},listRepositories:function(forceLoad,attributeStr){if(forceLoad){var apiCall=new UAPIREQUEST.Class;apiCall.initialize("VersionControl","retrieve");if(attributeStr){apiCall.addArgument("fields",attributeStr)}return this.deferred(apiCall).promise.then(function(response){try{repos=prepareList(response.data);return $q.resolve(repos)}catch(err){return $q.reject(err)}}).catch(function(error){return $q.reject(error)})}else{return $q.resolve(repos)}},getRepositoryInformation:function(repositoryPath,attributeStr){var apiCall=new UAPIREQUEST.Class;apiCall.initialize("VersionControl","retrieve");if(repositoryPath){apiCall.addFilter("repository_root","eq",repositoryPath);if(attributeStr){apiCall.addArgument("fields",attributeStr)}}else{throw new Error(LOCALE.maketext("Repository path cannot be empty."))}var repository=[];return this.deferred(apiCall).promise.then(function(response){try{repository=prepareList(response.data);if(repository&&repository.length>0){return $q.resolve(repository[0])}else{throw new Error(LOCALE.maketext("Repository “[_1]” could not be found.",repositoryPath))}}catch(err){return $q.reject(err)}}).catch(function(error){return $q.reject(error)})},cloneToClipboard:function(cloneUrl){if(typeof cloneUrl==="string"&&cloneUrl!==""){copyTextToClipboard(cloneUrl);return true}else{throw new Error(LOCALE.maketext("“[_1]” is not a valid clone [output,acronym,URL,Universal Resource Locator].",cloneUrl))}},createRepository:function(name,fullPath,cloneURL){var apiCall=new UAPIREQUEST.Class;apiCall.initialize("VersionControl","create");apiCall.addArgument("name",name);apiCall.addArgument("repository_root",fullPath);apiCall.addArgument("type","git");if(typeof cloneURL!=="undefined"&&cloneURL){apiCall.addArgument("source_repository",JSON.stringify({remote_name:"origin",url:cloneURL}))}return this.deferred(apiCall).promise.then(function(response){var processedData={};if(response.data){processedData=refineRepositoryInformation(response.data);repos.push(processedData)}return processedData}).catch(function(error){return $q.reject(error)})},deleteRepository:function(repositoryRoot){if(typeof repositoryRoot==="string"&&repositoryRoot!==""){var apiCall=new UAPIREQUEST.Class;apiCall.initialize("VersionControl","delete");apiCall.addArgument("repository_root",repositoryRoot);return this.deferred(apiCall).promise.then(function(){var index=getRepositoryIndex(repos,repositoryRoot);if(typeof index==="number"&&index>=0){repos.splice(index,1)}return $q.resolve()}).catch(function(error){return $q.reject(error)})}},updateRepository:function(repositoryRoot,repositoryName,branch){var apiCall=new UAPIREQUEST.Class;apiCall.initialize("VersionControl","update");apiCall.addArgument("repository_root",repositoryRoot);if(typeof repositoryName==="string"&&repositoryName){apiCall.addArgument("name",repositoryName)}if(typeof branch==="string"&&branch){apiCall.addArgument("branch",branch)}return this.deferred(apiCall).promise.then(function(response){if(response.data){var index=getRepositoryIndex(repos,repositoryRoot);if(typeof index==="number"&&index>=0){repos[index]=refineRepositoryInformation(response.data)}}return response}).catch(function(error){return $q.reject(error)})},updateFromRemote:function(repositoryRoot,branch){var apiCall=new UAPIREQUEST.Class;apiCall.initialize("VersionControl","update");apiCall.addArgument("repository_root",repositoryRoot);apiCall.addArgument("branch",branch||"");return this.deferred(apiCall).promise.then(function(response){if(response.data){var index=getRepositoryIndex(repos,repositoryRoot);if(typeof index==="number"&&index>=0){repos[index]=refineRepositoryInformation(response.data)}}return response}).catch(function(error){return $q.reject(error)})},deployRepository:function(repositoryRoot){var apiCall=new UAPIREQUEST.Class;apiCall.initialize("VersionControlDeployment","create");apiCall.addArgument("repository_root",repositoryRoot);return this.deferred(apiCall).promise.then(function(response){return response}).catch(function(error){return $q.reject(error)})}});return new VersionControlService}])});