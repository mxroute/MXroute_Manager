(function(root) {
define("jquery-chosen", ["jquery"], function() {
  return (function() {
/*!
Chosen, a Select Box Enhancer for jQuery and Prototype
by Patrick Filler for Harvest, http://getharvest.com

Version 1.5.1
Full source at https://github.com/harvesthq/chosen
Copyright (c) 2011-2016 Harvest http://getharvest.com

MIT License, https://github.com/harvesthq/chosen/blob/master/LICENSE.md
This file is generated by `grunt build`, do not edit it by hand.
*/

(function() {
  var $, AbstractChosen, Chosen, SelectParser, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  SelectParser = (function() {
    function SelectParser() {
      this.options_index = 0;
      this.parsed = [];
    }

    SelectParser.prototype.add_node = function(child) {
      if (child.nodeName.toUpperCase() === "OPTGROUP") {
        return this.add_group(child);
      } else {
        return this.add_option(child);
      }
    };

    SelectParser.prototype.add_group = function(group) {
      var group_position, option, _i, _len, _ref, _results;
      group_position = this.parsed.length;
      this.parsed.push({
        array_index: group_position,
        group: true,
        label: this.escapeExpression(group.label),
        title: group.title ? group.title : void 0,
        children: 0,
        disabled: group.disabled,
        classes: group.className
      });
      _ref = group.childNodes;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        option = _ref[_i];
        _results.push(this.add_option(option, group_position, group.disabled));
      }
      return _results;
    };

    SelectParser.prototype.add_option = function(option, group_position, group_disabled) {
      if (option.nodeName.toUpperCase() === "OPTION") {
        if (option.text !== "") {
          if (group_position != null) {
            this.parsed[group_position].children += 1;
          }
          this.parsed.push({
            array_index: this.parsed.length,
            options_index: this.options_index,
            value: option.value,
            text: option.text,
            html: option.innerHTML,
            title: option.title ? option.title : void 0,
            selected: option.selected,
            disabled: group_disabled === true ? group_disabled : option.disabled,
            group_array_index: group_position,
            group_label: group_position != null ? this.parsed[group_position].label : null,
            classes: option.className,
            style: option.style.cssText
          });
        } else {
          this.parsed.push({
            array_index: this.parsed.length,
            options_index: this.options_index,
            empty: true
          });
        }
        return this.options_index += 1;
      }
    };

    SelectParser.prototype.escapeExpression = function(text) {
      var map, unsafe_chars;
      if ((text == null) || text === false) {
        return "";
      }
      if (!/[\&\<\>\"\'\`]/.test(text)) {
        return text;
      }
      map = {
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#x27;",
        "`": "&#x60;"
      };
      unsafe_chars = /&(?!\w+;)|[\<\>\"\'\`]/g;
      return text.replace(unsafe_chars, function(chr) {
        return map[chr] || "&amp;";
      });
    };

    return SelectParser;

  })();

  SelectParser.select_to_array = function(select) {
    var child, parser, _i, _len, _ref;
    parser = new SelectParser();
    _ref = select.childNodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      parser.add_node(child);
    }
    return parser.parsed;
  };

  AbstractChosen = (function() {
    function AbstractChosen(form_field, options) {
      this.form_field = form_field;
      this.options = options != null ? options : {};
      if (!AbstractChosen.browser_is_supported()) {
        return;
      }
      this.is_multiple = this.form_field.multiple;
      this.set_default_text();
      this.set_default_values();
      this.setup();
      this.set_up_html();
      this.register_observers();
      this.on_ready();
    }

    AbstractChosen.prototype.set_default_values = function() {
      var _this = this;
      this.click_test_action = function(evt) {
        return _this.test_active_click(evt);
      };
      this.activate_action = function(evt) {
        return _this.activate_field(evt);
      };
      this.active_field = false;
      this.mouse_on_container = false;
      this.results_showing = false;
      this.result_highlighted = null;
      this.allow_single_deselect = (this.options.allow_single_deselect != null) && (this.form_field.options[0] != null) && this.form_field.options[0].text === "" ? this.options.allow_single_deselect : false;
      this.disable_search_threshold = this.options.disable_search_threshold || 0;
      this.disable_search = this.options.disable_search || false;
      this.enable_split_word_search = this.options.enable_split_word_search != null ? this.options.enable_split_word_search : true;
      this.group_search = this.options.group_search != null ? this.options.group_search : true;
      this.search_contains = this.options.search_contains || false;
      this.single_backstroke_delete = this.options.single_backstroke_delete != null ? this.options.single_backstroke_delete : true;
      this.max_selected_options = this.options.max_selected_options || Infinity;
      this.inherit_select_classes = this.options.inherit_select_classes || false;
      this.display_selected_options = this.options.display_selected_options != null ? this.options.display_selected_options : true;
      this.display_disabled_options = this.options.display_disabled_options != null ? this.options.display_disabled_options : true;
      this.include_group_label_in_selected = this.options.include_group_label_in_selected || false;
      return this.max_shown_results = this.options.max_shown_results || Number.POSITIVE_INFINITY;
    };

    AbstractChosen.prototype.set_default_text = function() {
      if (this.form_field.getAttribute("data-placeholder")) {
        this.default_text = this.form_field.getAttribute("data-placeholder");
      } else if (this.is_multiple) {
        this.default_text = this.options.placeholder_text_multiple || this.options.placeholder_text || AbstractChosen.default_multiple_text;
      } else {
        this.default_text = this.options.placeholder_text_single || this.options.placeholder_text || AbstractChosen.default_single_text;
      }
      return this.results_none_found = this.form_field.getAttribute("data-no_results_text") || this.options.no_results_text || AbstractChosen.default_no_result_text;
    };

    AbstractChosen.prototype.choice_label = function(item) {
      if (this.include_group_label_in_selected && (item.group_label != null)) {
        return "<b class='group-name'>" + item.group_label + "</b>" + item.html;
      } else {
        return item.html;
      }
    };

    AbstractChosen.prototype.mouse_enter = function() {
      return this.mouse_on_container = true;
    };

    AbstractChosen.prototype.mouse_leave = function() {
      return this.mouse_on_container = false;
    };

    AbstractChosen.prototype.input_focus = function(evt) {
      var _this = this;
      if (this.is_multiple) {
        if (!this.active_field) {
          return setTimeout((function() {
            return _this.container_mousedown();
          }), 50);
        }
      } else {
        if (!this.active_field) {
          return this.activate_field();
        }
      }
    };

    AbstractChosen.prototype.input_blur = function(evt) {
      var _this = this;
      if (!this.mouse_on_container) {
        this.active_field = false;
        return setTimeout((function() {
          return _this.blur_test();
        }), 100);
      }
    };

    AbstractChosen.prototype.results_option_build = function(options) {
      var content, data, data_content, shown_results, _i, _len, _ref;
      content = '';
      shown_results = 0;
      _ref = this.results_data;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        data = _ref[_i];
        data_content = '';
        if (data.group) {
          data_content = this.result_add_group(data);
        } else {
          data_content = this.result_add_option(data);
        }
        if (data_content !== '') {
          shown_results++;
          content += data_content;
        }
        if (options != null ? options.first : void 0) {
          if (data.selected && this.is_multiple) {
            this.choice_build(data);
          } else if (data.selected && !this.is_multiple) {
            this.single_set_selected_text(this.choice_label(data));
          }
        }
        if (shown_results >= this.max_shown_results) {
          break;
        }
      }
      return content;
    };

    AbstractChosen.prototype.result_add_option = function(option) {
      var classes, option_el;
      if (!option.search_match) {
        return '';
      }
      if (!this.include_option_in_results(option)) {
        return '';
      }
      classes = [];
      if (!option.disabled && !(option.selected && this.is_multiple)) {
        classes.push("active-result");
      }
      if (option.disabled && !(option.selected && this.is_multiple)) {
        classes.push("disabled-result");
      }
      if (option.selected) {
        classes.push("result-selected");
      }
      if (option.group_array_index != null) {
        classes.push("group-option");
      }
      if (option.classes !== "") {
        classes.push(option.classes);
      }
      option_el = document.createElement("li");
      option_el.className = classes.join(" ");
      option_el.style.cssText = option.style;
      option_el.setAttribute("data-option-array-index", option.array_index);
      option_el.innerHTML = option.search_text;
      if (option.title) {
        option_el.title = option.title;
      }
      return this.outerHTML(option_el);
    };

    AbstractChosen.prototype.result_add_group = function(group) {
      var classes, group_el;
      if (!(group.search_match || group.group_match)) {
        return '';
      }
      if (!(group.active_options > 0)) {
        return '';
      }
      classes = [];
      classes.push("group-result");
      if (group.classes) {
        classes.push(group.classes);
      }
      group_el = document.createElement("li");
      group_el.className = classes.join(" ");
      group_el.innerHTML = group.search_text;
      if (group.title) {
        group_el.title = group.title;
      }
      return this.outerHTML(group_el);
    };

    AbstractChosen.prototype.results_update_field = function() {
      this.set_default_text();
      if (!this.is_multiple) {
        this.results_reset_cleanup();
      }
      this.result_clear_highlight();
      this.results_build();
      if (this.results_showing) {
        return this.winnow_results();
      }
    };

    AbstractChosen.prototype.reset_single_select_options = function() {
      var result, _i, _len, _ref, _results;
      _ref = this.results_data;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        result = _ref[_i];
        if (result.selected) {
          _results.push(result.selected = false);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    AbstractChosen.prototype.results_toggle = function() {
      if (this.results_showing) {
        return this.results_hide();
      } else {
        return this.results_show();
      }
    };

    AbstractChosen.prototype.results_search = function(evt) {
      if (this.results_showing) {
        return this.winnow_results();
      } else {
        return this.results_show();
      }
    };

    AbstractChosen.prototype.winnow_results = function() {
      var escapedSearchText, option, regex, results, results_group, searchText, startpos, text, zregex, _i, _len, _ref;
      this.no_results_clear();
      results = 0;
      searchText = this.get_search_text();
      escapedSearchText = searchText.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
      zregex = new RegExp(escapedSearchText, 'i');
      regex = this.get_search_regex(escapedSearchText);
      _ref = this.results_data;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        option = _ref[_i];
        option.search_match = false;
        results_group = null;
        if (this.include_option_in_results(option)) {
          if (option.group) {
            option.group_match = false;
            option.active_options = 0;
          }
          if ((option.group_array_index != null) && this.results_data[option.group_array_index]) {
            results_group = this.results_data[option.group_array_index];
            if (results_group.active_options === 0 && results_group.search_match) {
              results += 1;
            }
            results_group.active_options += 1;
          }
          option.search_text = option.group ? option.label : option.html;
          if (!(option.group && !this.group_search)) {
            option.search_match = this.search_string_match(option.search_text, regex);
            if (option.search_match && !option.group) {
              results += 1;
            }
            if (option.search_match) {
              if (searchText.length) {
                startpos = option.search_text.search(zregex);
                text = option.search_text.substr(0, startpos + searchText.length) + '</em>' + option.search_text.substr(startpos + searchText.length);
                option.search_text = text.substr(0, startpos) + '<em>' + text.substr(startpos);
              }
              if (results_group != null) {
                results_group.group_match = true;
              }
            } else if ((option.group_array_index != null) && this.results_data[option.group_array_index].search_match) {
              option.search_match = true;
            }
          }
        }
      }
      this.result_clear_highlight();
      if (results < 1 && searchText.length) {
        this.update_results_content("");
        return this.no_results(searchText);
      } else {
        this.update_results_content(this.results_option_build());
        return this.winnow_results_set_highlight();
      }
    };

    AbstractChosen.prototype.get_search_regex = function(escaped_search_string) {
      var regex_anchor;
      regex_anchor = this.search_contains ? "" : "^";
      return new RegExp(regex_anchor + escaped_search_string, 'i');
    };

    AbstractChosen.prototype.search_string_match = function(search_string, regex) {
      var part, parts, _i, _len;
      if (regex.test(search_string)) {
        return true;
      } else if (this.enable_split_word_search && (search_string.indexOf(" ") >= 0 || search_string.indexOf("[") === 0)) {
        parts = search_string.replace(/\[|\]/g, "").split(" ");
        if (parts.length) {
          for (_i = 0, _len = parts.length; _i < _len; _i++) {
            part = parts[_i];
            if (regex.test(part)) {
              return true;
            }
          }
        }
      }
    };

    AbstractChosen.prototype.choices_count = function() {
      var option, _i, _len, _ref;
      if (this.selected_option_count != null) {
        return this.selected_option_count;
      }
      this.selected_option_count = 0;
      _ref = this.form_field.options;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        option = _ref[_i];
        if (option.selected) {
          this.selected_option_count += 1;
        }
      }
      return this.selected_option_count;
    };

    AbstractChosen.prototype.choices_click = function(evt) {
      evt.preventDefault();
      if (!(this.results_showing || this.is_disabled)) {
        return this.results_show();
      }
    };

    AbstractChosen.prototype.keyup_checker = function(evt) {
      var stroke, _ref;
      stroke = (_ref = evt.which) != null ? _ref : evt.keyCode;
      this.search_field_scale();
      switch (stroke) {
        case 8:
          if (this.is_multiple && this.backstroke_length < 1 && this.choices_count() > 0) {
            return this.keydown_backstroke();
          } else if (!this.pending_backstroke) {
            this.result_clear_highlight();
            return this.results_search();
          }
          break;
        case 13:
          evt.preventDefault();
          if (this.results_showing) {
            return this.result_select(evt);
          }
          break;
        case 27:
          if (this.results_showing) {
            this.results_hide();
          }
          return true;
        case 9:
        case 38:
        case 40:
        case 16:
        case 91:
        case 17:
        case 18:
          break;
        default:
          return this.results_search();
      }
    };

    AbstractChosen.prototype.clipboard_event_checker = function(evt) {
      var _this = this;
      return setTimeout((function() {
        return _this.results_search();
      }), 50);
    };

    AbstractChosen.prototype.container_width = function() {
      if (this.options.width != null) {
        return this.options.width;
      } else {
        return "" + this.form_field.offsetWidth + "px";
      }
    };

    AbstractChosen.prototype.include_option_in_results = function(option) {
      if (this.is_multiple && (!this.display_selected_options && option.selected)) {
        return false;
      }
      if (!this.display_disabled_options && option.disabled) {
        return false;
      }
      if (option.empty) {
        return false;
      }
      return true;
    };

    AbstractChosen.prototype.search_results_touchstart = function(evt) {
      this.touch_started = true;
      return this.search_results_mouseover(evt);
    };

    AbstractChosen.prototype.search_results_touchmove = function(evt) {
      this.touch_started = false;
      return this.search_results_mouseout(evt);
    };

    AbstractChosen.prototype.search_results_touchend = function(evt) {
      if (this.touch_started) {
        return this.search_results_mouseup(evt);
      }
    };

    AbstractChosen.prototype.outerHTML = function(element) {
      var tmp;
      if (element.outerHTML) {
        return element.outerHTML;
      }
      tmp = document.createElement("div");
      tmp.appendChild(element);
      return tmp.innerHTML;
    };

    AbstractChosen.browser_is_supported = function() {
      if (/iP(od|hone)/i.test(window.navigator.userAgent)) {
        return false;
      }
      if (/Android/i.test(window.navigator.userAgent)) {
        if (/Mobile/i.test(window.navigator.userAgent)) {
          return false;
        }
      }
      if (/IEMobile/i.test(window.navigator.userAgent)) {
        return false;
      }
      if (/Windows Phone/i.test(window.navigator.userAgent)) {
        return false;
      }
      if (/BlackBerry/i.test(window.navigator.userAgent)) {
        return false;
      }
      if (/BB10/i.test(window.navigator.userAgent)) {
        return false;
      }
      if (window.navigator.appName === "Microsoft Internet Explorer") {
        return document.documentMode >= 8;
      }
      return true;
    };

    AbstractChosen.default_multiple_text = "Select Some Options";

    AbstractChosen.default_single_text = "Select an Option";

    AbstractChosen.default_no_result_text = "No results match";

    return AbstractChosen;

  })();

  $ = jQuery;

  $.fn.extend({
    chosen: function(options) {
      if (!AbstractChosen.browser_is_supported()) {
        return this;
      }
      return this.each(function(input_field) {
        var $this, chosen;
        $this = $(this);
        chosen = $this.data('chosen');
        if (options === 'destroy') {
          if (chosen instanceof Chosen) {
            chosen.destroy();
          }
          return;
        }
        if (!(chosen instanceof Chosen)) {
          $this.data('chosen', new Chosen(this, options));
        }
      });
    }
  });

  Chosen = (function(_super) {
    __extends(Chosen, _super);

    function Chosen() {
      _ref = Chosen.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    Chosen.prototype.setup = function() {
      this.form_field_jq = $(this.form_field);
      this.current_selectedIndex = this.form_field.selectedIndex;
      return this.is_rtl = this.form_field_jq.hasClass("chosen-rtl");
    };

    Chosen.prototype.set_up_html = function() {
      var container_classes, container_props;
      container_classes = ["chosen-container"];
      container_classes.push("chosen-container-" + (this.is_multiple ? "multi" : "single"));
      if (this.inherit_select_classes && this.form_field.className) {
        container_classes.push(this.form_field.className);
      }
      if (this.is_rtl) {
        container_classes.push("chosen-rtl");
      }
      container_props = {
        'class': container_classes.join(' '),
        'style': "width: " + (this.container_width()) + ";",
        'title': this.form_field.title
      };
      if (this.form_field.id.length) {
        container_props.id = this.form_field.id.replace(/[^\w]/g, '_') + "_chosen";
      }
      this.container = $("<div />", container_props);
      if (this.is_multiple) {
        this.container.html('<ul class="chosen-choices"><li class="search-field"><input type="text" value="' + this.default_text + '" class="default" autocomplete="off" style="width:25px;" /></li></ul><div class="chosen-drop"><ul class="chosen-results"></ul></div>');
      } else {
        this.container.html('<a class="chosen-single chosen-default"><span>' + this.default_text + '</span><div><b></b></div></a><div class="chosen-drop"><div class="chosen-search"><input type="text" autocomplete="off" /></div><ul class="chosen-results"></ul></div>');
      }
      this.form_field_jq.hide().after(this.container);
      this.dropdown = this.container.find('div.chosen-drop').first();
      this.search_field = this.container.find('input').first();
      this.search_results = this.container.find('ul.chosen-results').first();
      this.search_field_scale();
      this.search_no_results = this.container.find('li.no-results').first();
      if (this.is_multiple) {
        this.search_choices = this.container.find('ul.chosen-choices').first();
        this.search_container = this.container.find('li.search-field').first();
      } else {
        this.search_container = this.container.find('div.chosen-search').first();
        this.selected_item = this.container.find('.chosen-single').first();
      }
      this.results_build();
      this.set_tab_index();
      return this.set_label_behavior();
    };

    Chosen.prototype.on_ready = function() {
      return this.form_field_jq.trigger("chosen:ready", {
        chosen: this
      });
    };

    Chosen.prototype.register_observers = function() {
      var _this = this;
      this.container.bind('touchstart.chosen', function(evt) {
        _this.container_mousedown(evt);
        return evt.preventDefault();
      });
      this.container.bind('touchend.chosen', function(evt) {
        _this.container_mouseup(evt);
        return evt.preventDefault();
      });
      this.container.bind('mousedown.chosen', function(evt) {
        _this.container_mousedown(evt);
      });
      this.container.bind('mouseup.chosen', function(evt) {
        _this.container_mouseup(evt);
      });
      this.container.bind('mouseenter.chosen', function(evt) {
        _this.mouse_enter(evt);
      });
      this.container.bind('mouseleave.chosen', function(evt) {
        _this.mouse_leave(evt);
      });
      this.search_results.bind('mouseup.chosen', function(evt) {
        _this.search_results_mouseup(evt);
      });
      this.search_results.bind('mouseover.chosen', function(evt) {
        _this.search_results_mouseover(evt);
      });
      this.search_results.bind('mouseout.chosen', function(evt) {
        _this.search_results_mouseout(evt);
      });
      this.search_results.bind('mousewheel.chosen DOMMouseScroll.chosen', function(evt) {
        _this.search_results_mousewheel(evt);
      });
      this.search_results.bind('touchstart.chosen', function(evt) {
        _this.search_results_touchstart(evt);
      });
      this.search_results.bind('touchmove.chosen', function(evt) {
        _this.search_results_touchmove(evt);
      });
      this.search_results.bind('touchend.chosen', function(evt) {
        _this.search_results_touchend(evt);
      });
      this.form_field_jq.bind("chosen:updated.chosen", function(evt) {
        _this.results_update_field(evt);
      });
      this.form_field_jq.bind("chosen:activate.chosen", function(evt) {
        _this.activate_field(evt);
      });
      this.form_field_jq.bind("chosen:open.chosen", function(evt) {
        _this.container_mousedown(evt);
      });
      this.form_field_jq.bind("chosen:close.chosen", function(evt) {
        _this.input_blur(evt);
      });
      this.search_field.bind('blur.chosen', function(evt) {
        _this.input_blur(evt);
      });
      this.search_field.bind('keyup.chosen', function(evt) {
        _this.keyup_checker(evt);
      });
      this.search_field.bind('keydown.chosen', function(evt) {
        _this.keydown_checker(evt);
      });
      this.search_field.bind('focus.chosen', function(evt) {
        _this.input_focus(evt);
      });
      this.search_field.bind('cut.chosen', function(evt) {
        _this.clipboard_event_checker(evt);
      });
      this.search_field.bind('paste.chosen', function(evt) {
        _this.clipboard_event_checker(evt);
      });
      if (this.is_multiple) {
        return this.search_choices.bind('click.chosen', function(evt) {
          _this.choices_click(evt);
        });
      } else {
        return this.container.bind('click.chosen', function(evt) {
          evt.preventDefault();
        });
      }
    };

    Chosen.prototype.destroy = function() {
      $(this.container[0].ownerDocument).unbind("click.chosen", this.click_test_action);
      if (this.search_field[0].tabIndex) {
        this.form_field_jq[0].tabIndex = this.search_field[0].tabIndex;
      }
      this.container.remove();
      this.form_field_jq.removeData('chosen');
      return this.form_field_jq.show();
    };

    Chosen.prototype.search_field_disabled = function() {
      this.is_disabled = this.form_field_jq[0].disabled;
      if (this.is_disabled) {
        this.container.addClass('chosen-disabled');
        this.search_field[0].disabled = true;
        if (!this.is_multiple) {
          this.selected_item.unbind("focus.chosen", this.activate_action);
        }
        return this.close_field();
      } else {
        this.container.removeClass('chosen-disabled');
        this.search_field[0].disabled = false;
        if (!this.is_multiple) {
          return this.selected_item.bind("focus.chosen", this.activate_action);
        }
      }
    };

    Chosen.prototype.container_mousedown = function(evt) {
      if (!this.is_disabled) {
        if (evt && evt.type === "mousedown" && !this.results_showing) {
          evt.preventDefault();
        }
        if (!((evt != null) && ($(evt.target)).hasClass("search-choice-close"))) {
          if (!this.active_field) {
            if (this.is_multiple) {
              this.search_field.val("");
            }
            $(this.container[0].ownerDocument).bind('click.chosen', this.click_test_action);
            this.results_show();
          } else if (!this.is_multiple && evt && (($(evt.target)[0] === this.selected_item[0]) || $(evt.target).parents("a.chosen-single").length)) {
            evt.preventDefault();
            this.results_toggle();
          }
          return this.activate_field();
        }
      }
    };

    Chosen.prototype.container_mouseup = function(evt) {
      if (evt.target.nodeName === "ABBR" && !this.is_disabled) {
        return this.results_reset(evt);
      }
    };

    Chosen.prototype.search_results_mousewheel = function(evt) {
      var delta;
      if (evt.originalEvent) {
        delta = evt.originalEvent.deltaY || -evt.originalEvent.wheelDelta || evt.originalEvent.detail;
      }
      if (delta != null) {
        evt.preventDefault();
        if (evt.type === 'DOMMouseScroll') {
          delta = delta * 40;
        }
        return this.search_results.scrollTop(delta + this.search_results.scrollTop());
      }
    };

    Chosen.prototype.blur_test = function(evt) {
      if (!this.active_field && this.container.hasClass("chosen-container-active")) {
        return this.close_field();
      }
    };

    Chosen.prototype.close_field = function() {
      $(this.container[0].ownerDocument).unbind("click.chosen", this.click_test_action);
      this.active_field = false;
      this.results_hide();
      this.container.removeClass("chosen-container-active");
      this.clear_backstroke();
      this.show_search_field_default();
      return this.search_field_scale();
    };

    Chosen.prototype.activate_field = function() {
      this.container.addClass("chosen-container-active");
      this.active_field = true;
      this.search_field.val(this.search_field.val());
      return this.search_field.focus();
    };

    Chosen.prototype.test_active_click = function(evt) {
      var active_container;
      active_container = $(evt.target).closest('.chosen-container');
      if (active_container.length && this.container[0] === active_container[0]) {
        return this.active_field = true;
      } else {
        return this.close_field();
      }
    };

    Chosen.prototype.results_build = function() {
      this.parsing = true;
      this.selected_option_count = null;
      this.results_data = SelectParser.select_to_array(this.form_field);
      if (this.is_multiple) {
        this.search_choices.find("li.search-choice").remove();
      } else if (!this.is_multiple) {
        this.single_set_selected_text();
        if (this.disable_search || this.form_field.options.length <= this.disable_search_threshold) {
          this.search_field[0].readOnly = true;
          this.container.addClass("chosen-container-single-nosearch");
        } else {
          this.search_field[0].readOnly = false;
          this.container.removeClass("chosen-container-single-nosearch");
        }
      }
      this.update_results_content(this.results_option_build({
        first: true
      }));
      this.search_field_disabled();
      this.show_search_field_default();
      this.search_field_scale();
      return this.parsing = false;
    };

    Chosen.prototype.result_do_highlight = function(el) {
      var high_bottom, high_top, maxHeight, visible_bottom, visible_top;
      if (el.length) {
        this.result_clear_highlight();
        this.result_highlight = el;
        this.result_highlight.addClass("highlighted");
        maxHeight = parseInt(this.search_results.css("maxHeight"), 10);
        visible_top = this.search_results.scrollTop();
        visible_bottom = maxHeight + visible_top;
        high_top = this.result_highlight.position().top + this.search_results.scrollTop();
        high_bottom = high_top + this.result_highlight.outerHeight();
        if (high_bottom >= visible_bottom) {
          return this.search_results.scrollTop((high_bottom - maxHeight) > 0 ? high_bottom - maxHeight : 0);
        } else if (high_top < visible_top) {
          return this.search_results.scrollTop(high_top);
        }
      }
    };

    Chosen.prototype.result_clear_highlight = function() {
      if (this.result_highlight) {
        this.result_highlight.removeClass("highlighted");
      }
      return this.result_highlight = null;
    };

    Chosen.prototype.results_show = function() {
      if (this.is_multiple && this.max_selected_options <= this.choices_count()) {
        this.form_field_jq.trigger("chosen:maxselected", {
          chosen: this
        });
        return false;
      }
      this.container.addClass("chosen-with-drop");
      this.results_showing = true;
      this.search_field.focus();
      this.search_field.val(this.search_field.val());
      this.winnow_results();
      return this.form_field_jq.trigger("chosen:showing_dropdown", {
        chosen: this
      });
    };

    Chosen.prototype.update_results_content = function(content) {
      return this.search_results.html(content);
    };

    Chosen.prototype.results_hide = function() {
      if (this.results_showing) {
        this.result_clear_highlight();
        this.container.removeClass("chosen-with-drop");
        this.form_field_jq.trigger("chosen:hiding_dropdown", {
          chosen: this
        });
      }
      return this.results_showing = false;
    };

    Chosen.prototype.set_tab_index = function(el) {
      var ti;
      if (this.form_field.tabIndex) {
        ti = this.form_field.tabIndex;
        this.form_field.tabIndex = -1;
        return this.search_field[0].tabIndex = ti;
      }
    };

    Chosen.prototype.set_label_behavior = function() {
      var _this = this;
      this.form_field_label = this.form_field_jq.parents("label");
      if (!this.form_field_label.length && this.form_field.id.length) {
        this.form_field_label = $("label[for='" + this.form_field.id + "']");
      }
      if (this.form_field_label.length > 0) {
        return this.form_field_label.bind('click.chosen', function(evt) {
          if (_this.is_multiple) {
            return _this.container_mousedown(evt);
          } else {
            return _this.activate_field();
          }
        });
      }
    };

    Chosen.prototype.show_search_field_default = function() {
      if (this.is_multiple && this.choices_count() < 1 && !this.active_field) {
        this.search_field.val(this.default_text);
        return this.search_field.addClass("default");
      } else {
        this.search_field.val("");
        return this.search_field.removeClass("default");
      }
    };

    Chosen.prototype.search_results_mouseup = function(evt) {
      var target;
      target = $(evt.target).hasClass("active-result") ? $(evt.target) : $(evt.target).parents(".active-result").first();
      if (target.length) {
        this.result_highlight = target;
        this.result_select(evt);
        return this.search_field.focus();
      }
    };

    Chosen.prototype.search_results_mouseover = function(evt) {
      var target;
      target = $(evt.target).hasClass("active-result") ? $(evt.target) : $(evt.target).parents(".active-result").first();
      if (target) {
        return this.result_do_highlight(target);
      }
    };

    Chosen.prototype.search_results_mouseout = function(evt) {
      if ($(evt.target).hasClass("active-result" || $(evt.target).parents('.active-result').first())) {
        return this.result_clear_highlight();
      }
    };

    Chosen.prototype.choice_build = function(item) {
      var choice, close_link,
        _this = this;
      choice = $('<li />', {
        "class": "search-choice"
      }).html("<span>" + (this.choice_label(item)) + "</span>");
      if (item.disabled) {
        choice.addClass('search-choice-disabled');
      } else {
        close_link = $('<a />', {
          "class": 'search-choice-close',
          'data-option-array-index': item.array_index
        });
        close_link.bind('click.chosen', function(evt) {
          return _this.choice_destroy_link_click(evt);
        });
        choice.append(close_link);
      }
      return this.search_container.before(choice);
    };

    Chosen.prototype.choice_destroy_link_click = function(evt) {
      evt.preventDefault();
      evt.stopPropagation();
      if (!this.is_disabled) {
        return this.choice_destroy($(evt.target));
      }
    };

    Chosen.prototype.choice_destroy = function(link) {
      if (this.result_deselect(link[0].getAttribute("data-option-array-index"))) {
        this.show_search_field_default();
        if (this.is_multiple && this.choices_count() > 0 && this.search_field.val().length < 1) {
          this.results_hide();
        }
        link.parents('li').first().remove();
        return this.search_field_scale();
      }
    };

    Chosen.prototype.results_reset = function() {
      this.reset_single_select_options();
      this.form_field.options[0].selected = true;
      this.single_set_selected_text();
      this.show_search_field_default();
      this.results_reset_cleanup();
      this.form_field_jq.trigger("change");
      if (this.active_field) {
        return this.results_hide();
      }
    };

    Chosen.prototype.results_reset_cleanup = function() {
      this.current_selectedIndex = this.form_field.selectedIndex;
      return this.selected_item.find("abbr").remove();
    };

    Chosen.prototype.result_select = function(evt) {
      var high, item;
      if (this.result_highlight) {
        high = this.result_highlight;
        this.result_clear_highlight();
        if (this.is_multiple && this.max_selected_options <= this.choices_count()) {
          this.form_field_jq.trigger("chosen:maxselected", {
            chosen: this
          });
          return false;
        }
        if (this.is_multiple) {
          high.removeClass("active-result");
        } else {
          this.reset_single_select_options();
        }
        high.addClass("result-selected");
        item = this.results_data[high[0].getAttribute("data-option-array-index")];
        item.selected = true;
        this.form_field.options[item.options_index].selected = true;
        this.selected_option_count = null;
        if (this.is_multiple) {
          this.choice_build(item);
        } else {
          this.single_set_selected_text(this.choice_label(item));
        }
        if (!((evt.metaKey || evt.ctrlKey) && this.is_multiple)) {
          this.results_hide();
        }
        this.show_search_field_default();
        if (this.is_multiple || this.form_field.selectedIndex !== this.current_selectedIndex) {
          this.form_field_jq.trigger("change", {
            'selected': this.form_field.options[item.options_index].value
          });
        }
        this.current_selectedIndex = this.form_field.selectedIndex;
        evt.preventDefault();
        return this.search_field_scale();
      }
    };

    Chosen.prototype.single_set_selected_text = function(text) {
      if (text == null) {
        text = this.default_text;
      }
      if (text === this.default_text) {
        this.selected_item.addClass("chosen-default");
      } else {
        this.single_deselect_control_build();
        this.selected_item.removeClass("chosen-default");
      }
      return this.selected_item.find("span").html(text);
    };

    Chosen.prototype.result_deselect = function(pos) {
      var result_data;
      result_data = this.results_data[pos];
      if (!this.form_field.options[result_data.options_index].disabled) {
        result_data.selected = false;
        this.form_field.options[result_data.options_index].selected = false;
        this.selected_option_count = null;
        this.result_clear_highlight();
        if (this.results_showing) {
          this.winnow_results();
        }
        this.form_field_jq.trigger("change", {
          deselected: this.form_field.options[result_data.options_index].value
        });
        this.search_field_scale();
        return true;
      } else {
        return false;
      }
    };

    Chosen.prototype.single_deselect_control_build = function() {
      if (!this.allow_single_deselect) {
        return;
      }
      if (!this.selected_item.find("abbr").length) {
        this.selected_item.find("span").first().after("<abbr class=\"search-choice-close\"></abbr>");
      }
      return this.selected_item.addClass("chosen-single-with-deselect");
    };

    Chosen.prototype.get_search_text = function() {
      return $('<div/>').text($.trim(this.search_field.val())).html();
    };

    Chosen.prototype.winnow_results_set_highlight = function() {
      var do_high, selected_results;
      selected_results = !this.is_multiple ? this.search_results.find(".result-selected.active-result") : [];
      do_high = selected_results.length ? selected_results.first() : this.search_results.find(".active-result").first();
      if (do_high != null) {
        return this.result_do_highlight(do_high);
      }
    };

    Chosen.prototype.no_results = function(terms) {
      var no_results_html;
      no_results_html = $('<li class="no-results">' + this.results_none_found + ' "<span></span>"</li>');
      no_results_html.find("span").first().html(terms);
      this.search_results.append(no_results_html);
      return this.form_field_jq.trigger("chosen:no_results", {
        chosen: this
      });
    };

    Chosen.prototype.no_results_clear = function() {
      return this.search_results.find(".no-results").remove();
    };

    Chosen.prototype.keydown_arrow = function() {
      var next_sib;
      if (this.results_showing && this.result_highlight) {
        next_sib = this.result_highlight.nextAll("li.active-result").first();
        if (next_sib) {
          return this.result_do_highlight(next_sib);
        }
      } else {
        return this.results_show();
      }
    };

    Chosen.prototype.keyup_arrow = function() {
      var prev_sibs;
      if (!this.results_showing && !this.is_multiple) {
        return this.results_show();
      } else if (this.result_highlight) {
        prev_sibs = this.result_highlight.prevAll("li.active-result");
        if (prev_sibs.length) {
          return this.result_do_highlight(prev_sibs.first());
        } else {
          if (this.choices_count() > 0) {
            this.results_hide();
          }
          return this.result_clear_highlight();
        }
      }
    };

    Chosen.prototype.keydown_backstroke = function() {
      var next_available_destroy;
      if (this.pending_backstroke) {
        this.choice_destroy(this.pending_backstroke.find("a").first());
        return this.clear_backstroke();
      } else {
        next_available_destroy = this.search_container.siblings("li.search-choice").last();
        if (next_available_destroy.length && !next_available_destroy.hasClass("search-choice-disabled")) {
          this.pending_backstroke = next_available_destroy;
          if (this.single_backstroke_delete) {
            return this.keydown_backstroke();
          } else {
            return this.pending_backstroke.addClass("search-choice-focus");
          }
        }
      }
    };

    Chosen.prototype.clear_backstroke = function() {
      if (this.pending_backstroke) {
        this.pending_backstroke.removeClass("search-choice-focus");
      }
      return this.pending_backstroke = null;
    };

    Chosen.prototype.keydown_checker = function(evt) {
      var stroke, _ref1;
      stroke = (_ref1 = evt.which) != null ? _ref1 : evt.keyCode;
      this.search_field_scale();
      if (stroke !== 8 && this.pending_backstroke) {
        this.clear_backstroke();
      }
      switch (stroke) {
        case 8:
          this.backstroke_length = this.search_field.val().length;
          break;
        case 9:
          if (this.results_showing && !this.is_multiple) {
            this.result_select(evt);
          }
          this.mouse_on_container = false;
          break;
        case 13:
          if (this.results_showing) {
            evt.preventDefault();
          }
          break;
        case 32:
          if (this.disable_search) {
            evt.preventDefault();
          }
          break;
        case 38:
          evt.preventDefault();
          this.keyup_arrow();
          break;
        case 40:
          evt.preventDefault();
          this.keydown_arrow();
          break;
      }
    };

    Chosen.prototype.search_field_scale = function() {
      var div, f_width, h, style, style_block, styles, w, _i, _len;
      if (this.is_multiple) {
        h = 0;
        w = 0;
        style_block = "position:absolute; left: -1000px; top: -1000px; display:none;";
        styles = ['font-size', 'font-style', 'font-weight', 'font-family', 'line-height', 'text-transform', 'letter-spacing'];
        for (_i = 0, _len = styles.length; _i < _len; _i++) {
          style = styles[_i];
          style_block += style + ":" + this.search_field.css(style) + ";";
        }
        div = $('<div />', {
          'style': style_block
        });
        div.text(this.search_field.val());
        $('body').append(div);
        w = div.width() + 25;
        div.remove();
        f_width = this.container.outerWidth();
        if (w > f_width - 10) {
          w = f_width - 10;
        }
        return this.search_field.css({
          'width': w + 'px'
        });
      }
    };

    return Chosen;

  })(AbstractChosen);

}).call(this);


  }).apply(root, arguments);
});
}(this));

(function(root) {
define("angular-chosen", ["angular","jquery-chosen"], function() {
  return (function() {
/**
 * angular-chosen-localytics - Angular Chosen directive is an AngularJS Directive that brings the Chosen jQuery in a Angular way
 * @version v1.3.0
 * @link http://github.com/leocaseiro/angular-chosen
 * @license MIT
 */
(function() {
  var indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  angular.module('localytics.directives', []);

  angular.module('localytics.directives').directive('chosen', [
    '$timeout', function($timeout) {
      var CHOSEN_OPTION_WHITELIST, NG_OPTIONS_REGEXP, isEmpty, snakeCase;
      NG_OPTIONS_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/;
      CHOSEN_OPTION_WHITELIST = ['persistentCreateOption', 'createOptionText', 'createOption', 'skipNoResults', 'noResultsText', 'allowSingleDeselect', 'disableSearchThreshold', 'disableSearch', 'enableSplitWordSearch', 'inheritSelectClasses', 'maxSelectedOptions', 'placeholderTextMultiple', 'placeholderTextSingle', 'searchContains', 'singleBackstrokeDelete', 'displayDisabledOptions', 'displaySelectedOptions', 'width', 'includeGroupLabelInSelected', 'maxShownResults'];
      snakeCase = function(input) {
        return input.replace(/[A-Z]/g, function($1) {
          return "_" + ($1.toLowerCase());
        });
      };
      isEmpty = function(value) {
        var key;
        if (angular.isArray(value)) {
          return value.length === 0;
        } else if (angular.isObject(value)) {
          for (key in value) {
            if (value.hasOwnProperty(key)) {
              return false;
            }
          }
        }
        return true;
      };
      return {
        restrict: 'A',
        require: '?ngModel',
        priority: 1,
        link: function(scope, element, attr, ngModel) {
          var chosen, empty, initOrUpdate, match, options, origRender, startLoading, stopLoading, updateMessage, valuesExpr, viewWatch;
          scope.disabledValuesHistory = scope.disabledValuesHistory ? scope.disabledValuesHistory : [];
          element = $(element);
          element.addClass('localytics-chosen');
          options = scope.$eval(attr.chosen) || {};
          angular.forEach(attr, function(value, key) {
            if (indexOf.call(CHOSEN_OPTION_WHITELIST, key) >= 0) {
              return attr.$observe(key, function(value) {
                options[snakeCase(key)] = String(element.attr(attr.$attr[key])).slice(0, 2) === '{{' ? value : scope.$eval(value);
                return updateMessage();
              });
            }
          });
          startLoading = function() {
            return element.addClass('loading').attr('disabled', true).trigger('chosen:updated');
          };
          stopLoading = function() {
            element.removeClass('loading');
            if (angular.isDefined(attr.disabled)) {
              element.attr('disabled', attr.disabled);
            } else {
              element.attr('disabled', false);
            }
            return element.trigger('chosen:updated');
          };
          chosen = null;
          empty = false;
          initOrUpdate = function() {
            var defaultText;
            if (chosen) {
              return element.trigger('chosen:updated');
            } else {
              $timeout(function() {
                chosen = element.chosen(options).data('chosen');
              });
              if (angular.isObject(chosen)) {
                return defaultText = chosen.default_text;
              }
            }
          };
          updateMessage = function() {
            if (empty) {
              element.attr('data-placeholder', chosen.results_none_found).attr('disabled', true);
            } else {
              element.removeAttr('data-placeholder');
            }
            return element.trigger('chosen:updated');
          };
          if (ngModel) {
            origRender = ngModel.$render;
            ngModel.$render = function() {
              origRender();
              return initOrUpdate();
            };
            element.on('chosen:hiding_dropdown', function() {
              return scope.$apply(function() {
                return ngModel.$setTouched();
              });
            });
            if (attr.multiple) {
              viewWatch = function() {
                return ngModel.$viewValue;
              };
              scope.$watch(viewWatch, ngModel.$render, true);
            }
          } else {
            initOrUpdate();
          }
          attr.$observe('disabled', function() {
            return element.trigger('chosen:updated');
          });
          if (attr.ngOptions && ngModel) {
            match = attr.ngOptions.match(NG_OPTIONS_REGEXP);
            valuesExpr = match[7];
            scope.$watchCollection(valuesExpr, function(newVal, oldVal) {
              var timer;
              return timer = $timeout(function() {
                if (angular.isUndefined(newVal)) {
                  return startLoading();
                } else {
                  empty = isEmpty(newVal);
                  stopLoading();
                  return updateMessage();
                }
              });
            });
            return scope.$on('$destroy', function(event) {
              if (typeof timer !== "undefined" && timer !== null) {
                return $timeout.cancel(timer);
              }
            });
          }
        }
      };
    }
  ]);

}).call(this);


  }).apply(root, arguments);
});
}(this));

/*
 * wordpress/directives/modelToLowerCase.js           Copyright 2017 cPanel, Inc.
 *                                                           All rights Reserved.
 * copyright@cpanel.net                                         http://cpanel.net
 * This code is subject to the cPanel license. Unauthorized copying is prohibited
 */

/* global define: false */

define(
    'app/directives/modelToLowerCase',[
        "angular",
    ],
    function(angular) {

        /**
         * This directive simply adds a parser to transform input into lowercase before saving it to the model.
         *
         * Example: <input ng-model="myModel" model-to-lower-case>
         */
        angular.module("cpanel.wordpress").directive("modelToLowerCase", [
            function() {

                return {
                    restrict: "A",
                    require: "ngModel",
                    link: function(scope, elem, attrs, ngModel) {
                        ngModel.$parsers.unshift(function(viewVal) {
                            return viewVal.toLocaleLowerCase();
                        });
                    }
                };
            }
        ]);
    }
);

/*
 * wordpress/directives/listSearchArea.js             Copyright 2017 cPanel, Inc.
 *                                                           All rights Reserved.
 * copyright@cpanel.net                                         http://cpanel.net
 * This code is subject to the cPanel license. Unauthorized copying is prohibited
 */

/* global define: false */

define('app/directives/listSearchArea',[
    "angular",
    "cjt/core",
    "cjt/util/locale",
    "app/directives/modelToLowerCase",
], function(
    angular,
    CJT,
    LOCALE
) {

    /**
     * The search area for the instance selection/list view. Provides controls to
     * filter items in the list of installation instances.
     */

    var APP_RELATIVE_PATH = "directives/listSearchArea.ptt";
    var BASE_RELATIVE_PATH = "wordpress/" + APP_RELATIVE_PATH;

    angular.module("cpanel.wordpress").directive("listSearchArea", [
        function() {
            return {
                templateUrl: CJT.config.debug ? CJT.buildFullPath(BASE_RELATIVE_PATH) : BASE_RELATIVE_PATH,
            };
        }
    ]);
});
/*
 * wordpress/filters/removeHomePath.js                Copyright 2017 cPanel, Inc.
 *                                                           All rights Reserved.
 * copyright@cpanel.net                                         http://cpanel.net
 * This code is subject to the cPanel license. Unauthorized copying is prohibited
 */

/* global define: false */

define('app/filters/removeHomePath',[
    "angular",
    "lodash",
], function(
    angular,
    _
) {

    var app;
    try {
        app = angular.module("cpanel.wordpress");
    }
    catch(e) {
        // for unit tests that don't load the index.js
        app = angular.module("cpanel.wordpress", []);
    }

    return app.filter("removeHomePath", [
        "pageState",
        function(pageState) {

            /**
             * Trims the user's home directory off of the beginning of file paths.
             *
             * @param  {String} fullPath   The path that will be processed.
             * @return {String}            The trimmed path.
             */
            return function (fullPath) {
                if (!angular.isString(fullPath)) {
                    throw new Error("Filter: removeHomePath requires you to pass the fullPath as an argument.");
                }

                if (!pageState || !pageState.homeDir) {
                    throw new Error("Filter: removeHomePath depends on the injected pageState.homeDir variable that must be defined.");
                }

                var regex = new RegExp("^" + _.escapeRegExp(pageState.homeDir));
                return fullPath.replace(regex, "").replace(/^\/+/, "/");
            };
        }
    ]);
});
/*
 * wordpress/directives/listInstance.js               Copyright 2017 cPanel, Inc.
 *                                                           All rights Reserved.
 * copyright@cpanel.net                                         http://cpanel.net
 * This code is subject to the cPanel license. Unauthorized copying is prohibited
 */

/* global define: false */

define('app/directives/listInstance',[
    "angular",
    "cjt/core",
    "cjt/filters/wrapFilter",
    "app/filters/removeHomePath",
], function(
    angular,
    CJT
) {
    var APP_RELATIVE_PATH = "directives/listInstance.ptt";
    var BASE_RELATIVE_PATH = "wordpress/" + APP_RELATIVE_PATH;

    /**
     * An individual instance in the list of instances on the selction screen.
     */

    angular.module("cpanel.wordpress").directive("listInstance", function() {

        var InstallationInstance = function() {};
        angular.extend(InstallationInstance.prototype, {

            /**
             * Calls the provided onSelect handler.
             *
             * @method select
             */
            select: function() {
                this.onSelect({ instance: this.model });
            }
        });

        return {
            restrict: "A",
            controllerAs: "instance",
            bindToController: true,
            scope: {
                model: "=",
                onSelect: "&",
            },
            controller: InstallationInstance,
            templateUrl: CJT.config.debug ? CJT.buildFullPath(BASE_RELATIVE_PATH) : BASE_RELATIVE_PATH,
        };
    });
});
/*
 * wordpress/services/instancesApi.js                 Copyright 2017 cPanel, Inc.
 *                                                           All rights Reserved.
 * copyright@cpanel.net                                         http://cpanel.net
 * This code is subject to the cPanel license. Unauthorized copying is prohibited
 */

/* global define: false */
/* jshint -W100 */

define('app/services/instancesApi',[
    "angular",
    "lodash",
    "cjt/util/locale",
    "cjt/io/uapi-request",
    "cjt/io/uapi",
    "cjt/util/parse",

    // Modules without exports
    "cjt/services/APIService",
], function(
    angular,
    _,
    LOCALE,
    APIREQUEST,
    APIDRIVER,
    PARSER
) {
    "use strict";

    var app;
    try {
        app = angular.module("cpanel.wordpress");
    }
    catch(e) {
        // for unit tests that don't load the index.js
        app = angular.module("cpanel.wordpress", []);
    }

    app.factory("instancesApi", [
        "pageState",
        "$q",
        "$log",
        "APIService",
        function(
            pageState,
            $q,
            $log,
            APIService
        ) {

            var _instances;              // List of instances retrieved from the backend.
            var _instancesLookup;        // Lookup table of the instances by the
            var _invalidCount = 0;       // The number of raw entries that didn't make it past the parse filter.

            // We want to periodically update the
            // data if its grown stale.
            var _lastLoaded;
            var _cacheTime = 5 * 60 * 1000; // 5 minutes

            /**
             * @typedef {Instance}
             * @description The Instance includes the following public fields. There are additional
             * fields, but they are not intended for public consumption and may be removed in future
             * releases.
             *
             * @property {String}  id               unique identifier for an instance
             * @property {String}  addon_config     full path to the addon configuration file
             * @property {String}  addon_name       name of the addon perl module
             * @property {String}  addon_type       type of the addon: legacy, modern
             * @property {String}  admin_url        the url to access the admin site
             * @property {String}  admin_username   the username use to log into the admin interface
             * @property {String}  available_version reserved for future use.
             * @property {String}  current_version   reserved for future use.
             * @property {String}  db_name          name of the mysql database where the sites data is stored.
             * @property {String}  db_prefix        sql table prefix used with the tables for this install.
             * @property {String}  db_server        name of the mysql database server, usually localhost.
             * @property {String}  db_type          type of database server: mysql
             * @property {String}  db_usrename      mysql user name that secures the database.
             * @property {String}  domain           the domain where the site is hosted.
             * @property {String}  full_path        the full path where the sites files are hosted.
             * @property {String}  homedir          the cpanel users home directory
             * @property {String}  initial_install_version the version installed at the time the site was created.
             * @property {String}  rel_path         the relative path for the site in the root of the configured domain.
             * @property {String}  site_url         the url to access the site.
             * @property {String}  [migrated_from]  optional, if available, its the addon that originally managed this site before it was converted.
             * @property {Number}  [migrated_on]    optional, if available, its a UNIX timestamp indicating when the migration occurred.
             */

            return {

                /**
                 * Returns the list of installation instances. The method will only attempt a
                 * fetch from the API if the list is not already cached, otherwise it will not.
                 * Use the explicit fetch method if you need to refresh the list.
                 *
                 * @async
                 * @method get
                 * @param  {Object} args   An object specifying method options.
                 *   @param {Boolean} [args.force] If true will reload regardless of the cache state.
                 * @return {Promise} Resolves with an object containing the list of instances and the
                 * @throws {String}  If the remote request fails for any reason.
                 */
                get: function(args) {
                    args = args || {};

                    if( _instances &&
                        !args.force &&
                        !this._isCacheStale() ) {
                        return this._getListFromCache();
                    }
                    // Only load from the pre-fetch on the initial load
                    // otherwise, fetch from the server since its possibly
                    // stale.
                    else if(!args.force && pageState.instances) {
                        try {
                            return this._getListFromPrefetch();
                        } catch(error) {
                            // Fall-back here hoping that the api will return
                            // clean data where the pre-fetch did not for some
                            // reason.
                            return this.fetch();
                        }
                    } else {
                        return this.fetch();
                    }
                },

                /**
                 * Fetch a list of installation instances from the server via UAPI.
                 *
                 * @async
                 * @method fetch
                 * @return {Promise} Resolves with an object containing the list of instances and the
                 *                   number of instances from the API that failed validation.
                 * @throws {String}  If the remote request fails for any reason.
                 */
                fetch: function() {
                    var self = this;

                    if(pageState.instances || pageState.prefetchNonFatalErrors) {
                        delete pageState.instances;
                        delete pageState.prefetchNonFatalErrors;
                    }

                    var apiCall = new APIREQUEST.Class();
                    apiCall.initialize("WordPressInstanceManager", "get_instances");

                    var api = new APIService();
                    return api.deferred(apiCall).promise.then(
                        function success(response) {
                            try {
                                var raw = response && response.data && response.data.instances;
                                var errors = response && response.data && response.data.errors;
                                self._set({
                                    raw:    raw,
                                    parsed: self.parse(raw),
                                });
                                return self._getListFromCache({ nonFatalErrors: errors });
                            }
                            catch(error) {
                                return $q.reject(LOCALE.maketext("The system failed to parse the response from the API: [_1]", error));
                            }
                        },
                        function failure(error) {
                            return $q.reject(
                                LOCALE.maketext("The system failed to retrieve the list of your [asis,WordPress] installations from the server: [_1]", error)
                            );
                        }
                    );
                },

                /**
                 * Fetches a single instance by its id
                 *
                 * @async
                 * @method getById
                 * @param {Object} args
                 *   @param {Number}  args.id Unique identifier for the requested instances.
                 *   @param {Boolean} [args.force] If true will force an update from the backend.
                 * @return {Promise.<Instance>}
                 * @throws {String} If the remote request fails for any reason.
                 */
                getById: function(args) {
                    args = args || {};
                    var self = this;
                    var id = args.id;
                    if (!id) {
                        throw new Error(LOCALE.maketext("[asis,getById()] requires an ID argument."));
                    }

                    if(_instancesLookup &&
                       !args.force &&
                       !this._isCacheStale()) {
                        return self._getInstanceFromCache(id);
                    }
                    // Only load from the pre-fetch on the initial load
                    // otherwise, fetch from the server since its possibly
                    // stale.
                    else if(!args.force && pageState.instances) {
                        try {
                            return self._getListFromPrefetch()
                                       .then(function() {
                                            return self._getInstanceFromCache(id);
                                        }, function() {
                                            return self.fetchById(id);
                                        });
                        } catch(error) {
                            return self.fetchById(id);
                        }
                    }
                    else {
                        return self.fetchById(id);
                    }
                },


                /**
                 * Fetch an instance from the backend by its id.
                 *
                 * @async
                 * @method  fetchById
                 * @param  {String} id Unique identifier for the instance.
                 * @return {Promise.<Instance>}
                 * @throws {Promise.<String>} If the remote request fails for any reason.
                 */
                fetchById: function(id) {
                    if(!id) {
                        throw new Error(LOCALE.maketext("[asis,fetchById()] requires an ID argument."));
                    }

                    var self = this;
                    var apiCall = new APIREQUEST.Class();
                    apiCall.initialize("WordPressInstanceManager", "get_instance_by_id");
                    apiCall.addArgument("id", id);

                    var api = new APIService();
                    var def = api.deferred(apiCall);
                    return def.promise.then(
                        function success(response) {
                            if (response && response.data) {
                                var instance = self._parseInstance(response.data);
                                if (self._validateInstance(instance)) {
                                    self._setById(instance);
                                    return $q.resolve(instance);
                                } else {
                                    return $q.reject(LOCALE.maketext("The system retrieved the [asis,WordPress] installation with the “[_1]” ID, but the returned data contains empty or invalid fields.", id));
                                }
                            }
                            return $q.reject(
                                LOCALE.maketext("The system failed to retrieve the requested [asis,WordPress] installation with the following ID: [_1]", id)
                            );
                        },
                        function failure(error) {
                            return $q.reject(
                                LOCALE.maketext("The system failed to retrieve the requested [asis,WordPress] installation with “[_1]” ID from the server: [_2]", id, error)
                            );
                        }
                    );
                },

                /**
                 * Parses the JavaScript array returned from the list_addon_instances UAPI method. It
                 * filters out any malformed items and returns an array of installation instances, sorted
                 * by domain and installation directory, in that order.
                 *
                 * This method also creates a private hash table with the unique_id as the key for easy
                 * lookups by id within this service.
                 *
                 * @method parse
                 * @param  {Array} rawInstances The array as returned from the API (parse the JSON response first).
                 * @return {Array}              The parsed, filtered, and sorted array.
                 */
                parse: function(rawInstances) {
                    var self = this;
                    if(!angular.isArray(rawInstances)) {
                        throw new Error(LOCALE.maketext("[asis,parse()] requires an array argument."));
                    }

                    // Quick return for the degenerate case
                    if (!rawInstances.length) {
                        return [];
                    }

                    var parsedInstances = rawInstances.map(function(instance) {
                        return self._parseInstance(instance);
                    }).filter(function(parsedInstance) {
                        return self._validateInstance(parsedInstance);
                    });

                    return parsedInstances;
                },

                /**
                 * Find the index of an instance in the instance list (_instances). If no match is found,
                 * the method returns -1.
                 *
                 * @method indexOf
                 * @param  {Instance} search   An object containing domain, full_path, and id properties.
                 * @return {Number}            The index in _instances for the Instance matching the id,
                 *                             domain, and full_path of the search object. If no match is
                 *                             found, the return value is -1.
                 */
                indexOf: function(search) {
                    if(angular.isUndefined(search)) {
                        throw new Error(LOCALE.maketext("[asis,indexOf()] requires an instance object argument."));
                    }

                    // Find the lowest possible index in the list for the search instance's domain/full_path
                    var i = this._findInsertionIndex(search);

                    // Check each subsequent item until we find a matching ID or a non-matching domain/full_path
                    var curr;
                    for( var l = _instances.length; i < l; i++ ) {
                        curr = _instances[i];
                        if( curr.full_path !== search.full_path || curr.domain !== search.domain ) {
                            break;
                        }
                        else if( curr.id === search.id ) {
                            return i;
                        }
                    }
                    return -1;
                },

                /**
                 * Wrapper around _.sortedIndexBy for our sorting method.
                 *
                 * This method assumes that all instances in the instance cache have
                 * been validated (as they should be) and contain domain/full_path
                 * keys, which is what we sort the main list by.
                 *
                 * @method _findInsertionIndex
                 * @param  {Instance} search   The instance to use for search criteria.
                 * @return {Number}            The index where the search instance should
                 *                             be inserted to maintain proper sort order.
                 */
                _findInsertionIndex: function(search) {
                    return _.sortedIndexBy(_instances, search, function(item) {
                        return item.domain + item.full_path;
                    });
                },

                /**
                 * Change a WordPress user's password for a WordPress installation.
                 *
                 * @async
                 * @method changeUserPassword
                 * @param  {String} instanceId   The unique identifier for the installation instance.
                 * @param  {String} username     The user whose password will change.
                 * @param  {String} password     The new password.
                 * @returns {Promise}            Returns if the request is successful.
                 * @throws {String}              If the request fails.
                 */
                changeUserPassword: function(instanceId, username, password) {

                    if (!instanceId) {
                        return $q(function(resolve, reject) {
                            reject(LOCALE.maketext("You must provide an instance ID."));
                        });
                    }

                    if (!username) {
                        return $q(function(resolve, reject) {
                            reject(LOCALE.maketext("You must provide a username."));
                        });
                    }

                    if (!password) {
                        return $q(function(resolve, reject) {
                            reject(LOCALE.maketext("You must provide a password."));
                        });
                    }

                    var apiCall = new APIREQUEST.Class();
                    apiCall.initialize("WordPressInstanceManager", "change_user_password");
                    apiCall.addArgument("id",       instanceId);
                    apiCall.addArgument("user",     username);
                    apiCall.addArgument("password", password);

                    var api = new APIService();
                    return api.deferred(apiCall).promise;
                },

                /**
                 * Configure the major and minor autoupdate settings for a WordPress site.
                 *
                 * This has the side effect of updating the instance in the cache if any changes
                 * occur while processing this request on the server.
                 *
                 * @async
                 * @method configureAutoupdate
                 * @param  {String} instanceId   The unique identifier for the installation instance.
                 * @param  {Boolean} major     Whether to enable major updates
                 * @param  {Boolean} minor     Whether to enable minor and security updates
                 * @return {Promise.<Instance>} When successful.
                 * @throws {String} If the remote request fails.
                 */
                configureAutoupdate: function(instanceId, major, minor) {

                    var self = this;

                    if (!instanceId) {
                        return $q(function(resolve, reject) {
                            reject(LOCALE.maketext("You must provide an instance ID."));
                        });
                    }

                    var apiCall = new APIREQUEST.Class();
                    apiCall.initialize("WordPressInstanceManager", "configure_autoupdate");
                    apiCall.addArgument("id",       instanceId);
                    apiCall.addArgument("autoupdate.core.major", major ? 1 : 0);
                    apiCall.addArgument("autoupdate.core.minor", minor ? 1 : 0);

                    var api = new APIService();
                    return api.deferred(apiCall).promise.then(function(response){
                        if (response && response.data && response.data.after) {
                            var after = self._parseInstance(response.data.after);
                            var id = response.data.after.id;
                            if (self._validateInstance(after)) {
                                // Remove the old one from the cache.
                                self._removeById(instanceId);
                                // Add the new one to the cache.
                                self._setById(after);
                                return $q.resolve(after);
                            } else {
                                return $q.reject(LOCALE.maketext("The system retrieved the [asis,WordPress] installation with the “[_1]” ID, but the returned data contains empty or invalid fields.", id));
                            }
                        }
                        else {
                            var instance = _instancesLookup[instanceId];
                            if( instance ) {
                                instance.autoupdate = major || minor;
                            }
                        }
                        return $q.resolve();
                    });
                },

                /**
                 * Change the WordPress database password for a WordPress installation.
                 *
                 * @async
                 * @method changeDbPassword
                 * @param  {String} instanceId   The unique identifier for the installation instance.
                 * @param  {String} password     The new password.
                 * @return {Promise} When the remote request is successful
                 * @throws {String} If the remote request failed.
                 */
                changeDbPassword: function(instanceId, password) {

                    if (!instanceId) {
                        return $q(function(resolve, reject) {
                            reject(LOCALE.maketext("You must provide an instance ID."));
                        });
                    }

                    if (!password) {
                        return $q(function(resolve, reject) {
                            reject(LOCALE.maketext("You must provide a password."));
                        });
                    }

                    var apiCall = new APIREQUEST.Class();
                    apiCall.initialize("WordPressInstanceManager", "change_db_password");
                    apiCall.addArgument("id",       instanceId);
                    apiCall.addArgument("password", password);

                    var api = new APIService();
                    return api.deferred(apiCall).promise;
                },

                /**
                 * Clears the local cache so the services caches are in an uninitilized state.
                 *
                 * @method clear
                 */
                clear: function() {
                    _instances = undefined;
                    _instancesLookup = {};
                    _invalidCount = 0;
                    _lastLoaded = undefined;
                },

                /**
                 * Determine if the cache is stale.
                 *
                 * @method _isCacheStale
                 * @private
                 * @return {Boolean} true if the cache is stale, false otherwise.
                 */
                _isCacheStale: function() {
                    return !_lastLoaded || (Date.now() - _lastLoaded > _cacheTime);
                },

                /**
                 * Validate an instances that just was adjusted
                 * from backend.
                 *
                 * @method _validateInstance
                 * @private
                 * @param  {Object} instance Parsed instances otherwise ready for use.
                 * @return {Boolean}         true if the instance is valid, false otherwise.
                 */
                _validateInstance: function(instance) {
                    var keys = Object.keys(instance);
                    if (!keys || !keys.length) {
                        return false;
                    }

                    // Remove any instances that have missing
                    // or invalid information
                    var isValid = keys.every(function(key) {
                        var value = instance[key];

                        // All fields should be defined
                        if( !angular.isDefined( value ) ) {
                            $log.warn( LOCALE.maketext("The configuration contains an invalid field, “[_1]”, with a value of, “[_2]”.", key, "undefined"));
                            return false;
                        }

                        // String fields should be non-empty, except for rel_path which may be empty.
                        if (angular.isString( value ) && key !== "rel_path" && value === "") {
                            $log.warn( LOCALE.maketext("The configuration contains an invalid field, “[_1]”, with a value of, “[_2]”.", key, "empty string"));
                            return false;
                        }

                        return true;
                    });

                    if(!isValid) {
                        $log.warn( LOCALE.maketext("The instance “[_1]” does not contain a required value.", JSON.stringify(instance)) );
                    }

                    return isValid;
                },

                /**
                 * Parse a backend instance so it is ready for use in the application.
                 *
                 * @method _parseInstance
                 * @private
                 * @param  {Object} instance Raw instance provide by prefetch or by api call.
                 * @return {Object}          Cleaned up instance ready for JavaScript usage.
                 */
                _parseInstance: function(instance) {
                    if (angular.isDefined(instance.autoupdate)) {
                        instance.autoupdate = PARSER.parsePerlBoolean(instance.autoupdate);
                    }

                    if( angular.isString(instance.rel_path) ) {
                        instance.rel_path = instance.rel_path.replace(/\/+$/, "");
                    }

                    if( angular.isString(instance.full_path) ) {
                        instance.full_path = instance.full_path.replace(/\/+$/, "");
                    }

                    if( angular.isString(instance.domain) ) {
                        instance.domain = instance.domain.toLocaleLowerCase();
                    }

                    return instance;
                },

                /**
                 * Updates the cached stats for the service
                 *
                 * @private
                 * @method  _set
                 * @param {Object} args - Object with the following properties
                 *   @param {Array} args.raw    - Array of objects as passed from the server.
                 *   @param {Array} args.parsed - Array of objects as returned by the parse() method.
                 */
                _set: function(args) {
                    _instances = Object.freeze( this._sort(args.parsed) );

                    // Reset the lookup table and store the new values
                    _instancesLookup = {};
                    _instances.forEach(function(instance) {
                        _instancesLookup[ instance.id ] = instance;
                    });

                    _invalidCount = args.raw.length - _instances.length;
                    _lastLoaded = Date.now();
                },

                /**
                 * Removes an instance from the cache by its id.
                 *
                 * @private
                 * @method _removeById
                 * @param  {String} id Unique identifier for the install
                 */
                _removeById: function(id) {
                    var instance = _instancesLookup[id];
                    if (instance) {
                        delete _instancesLookup[id];

                        var index = this.indexOf(instance);
                        if (index > -1) {
                            // Since _instances is frozen, we create a new array before modifying
                            var newInstanceList = _instances.slice();
                            newInstanceList.splice(index, 1);

                            _instances = Object.freeze( newInstanceList );
                            _lastLoaded = Date.now();
                        }
                    }
                },

                /**
                 * Updates or adds an instance to the instance cache. Updates are based on the ID.
                 *
                 * @method _setById
                 * @private
                 * @param {Instance} newInstance  The new instance to incorporate into the list of instances.
                 */
                _setById: function(newInstance) {
                    var self = this;

                    var _updateInstance = function() {
                        // Create a new array, since _instances is frozen
                        var newInstanceList = _instances.slice();

                        // Remove the old version of the instance, if it exists
                        var existingInstance = _instancesLookup[ newInstance.id ];
                        if(existingInstance) {
                            var existingIndex = self.indexOf( existingInstance );
                            if (existingIndex > -1) {
                                // Updating an instance, so remove the existing index
                                newInstanceList.splice(existingIndex, 1);
                            }
                        }

                        // Insert the new instance
                        var newIndex = self._findInsertionIndex(newInstance);
                        newInstanceList.splice(newIndex, 0, newInstance);

                        _instances = Object.freeze( newInstanceList );
                        _instancesLookup[newInstance.id] = newInstance;
                        _lastLoaded = Date.now();
                    };

                    if (!_instances) {
                        // The list is not initialized, so do that first.
                        self.get().then(_updateInstance);
                    }
                    else {
                        _updateInstance();
                    }
                },

                /**
                 * Fetches the cached values by reference. Used for testing only to verify
                 * the cache works as expected.
                 *
                 * @private
                 * @method  _get
                 * @return {Object} With the following properties:
                 *    {Array}  instances       - List of instances from the backend
                 *    {Object} instancesLookup - Hash of the instances index by the instance id.
                 *    {Number} invalidCount    - Number of invalid items that failed the parsing.
                 *    {Number} lastLoaded      - Timestamp when the data was updated in the cache.
                 *    {Number} cacheTime       - Number of millisecond to cache the data.
                 */
                _get: function() {
                    return {
                        instances:       _instances,
                        instancesLookup: _instancesLookup,
                        invalidCount:    _invalidCount,
                        lastLoaded:      _lastLoaded,
                        cacheTime:       _cacheTime,
                    };
                },

                /**
                 * Initialize the local caches from the prefetched data.
                 *
                 * @method _getListFromPrefetch
                 * @private
                 * @return {[type]} [description]
                 */
                _getListFromPrefetch: function() {
                    // Store the instances in the cache
                    this._set({
                        raw:    pageState.instances,
                        parsed: this.parse(pageState.instances),
                    });

                    var prefetchNonFatalErrors = pageState.prefetchNonFatalErrors;

                    delete pageState.instances;
                    delete pageState.prefetchNonFatalErrors;

                    return this._getListFromCache({ nonFatalErrors: prefetchNonFatalErrors });
                },

                /**
                 * Generate a deferred resolve() from the cached data.
                 *
                 * @method _getListFromCache
                 * @private
                 * @param  {Object} args with the following properties:
                 * @param {Array} args.nonFatalErrors list of non-fatal errors detected.
                 * @return {Promise}
                 */
                _getListFromCache: function(args) {
                    var nonFatalErrors = args && angular.isArray(args.nonFatalErrors) && args.nonFatalErrors || [];
                    return $q(function(resolve) {
                        resolve({
                            instances:     _instances,
                            invalidCount:  _invalidCount,
                            nonFatalErrors: nonFatalErrors,
                        });
                    });
                },

                /**
                 * Retrieve the requested instance from the cache if available.
                 * It will just fetch it from the backend if not in the cache.
                 *
                 * @method _getInstanceFromCache
                 * @private
                 * @param  {String} id Unique identifier
                 * @return {Promise}
                 */
                _getInstanceFromCache: function(id) {
                    var instance = _instancesLookup[id];
                    if (instance) {
                        return $q.resolve(instance);
                    } else {
                        return this.fetchById(id);
                    }
                },

                /**
                 * Sort the passed list by domain and then full_path
                 *
                 * @method _sort
                 * @param  {Array} instances
                 * @return {Array}
                 */
                _sort: function(instances) {
                    return _.sortBy(instances, ["domain", "full_path"]);
                },

            };
        }
    ]);
});

/*
 * wordpress/views/listController.js                  Copyright 2017 cPanel, Inc.
 *                                                           All rights Reserved.
 * copyright@cpanel.net                                         http://cpanel.net
 * This code is subject to the cPanel license. Unauthorized copying is prohibited
 */

/* global define: false */

define(
    'app/views/listController',[
        "angular",
        "lodash",
        "cjt/util/locale",
        "uiBootstrap",
        "cjt/directives/disableAnimations",
        "cjt/directives/lastItem",
        "cjt/directives/pageSizeDirective",
        "cjt/directives/spinnerDirective",
        "app/directives/listSearchArea",
        "app/directives/listInstance",
        "app/services/instancesApi",
    ],
    function(angular, _, LOCALE) {

        // Retrieve the current application
        var app = angular.module("cpanel.wordpress");

        // Setup the controller
        var controller = app.controller(
            "listController", [
                "$scope",
                "$timeout",
                "$location",
                "growl",
                "instancesApi",
                "spinnerAPI",
                function(
                    $scope,
                    $timeout,
                    $location,
                    growl,
                    instancesApi,
                    spinnerAPI
                ) {

                    /**
                     * Initialize the scope variables
                     *
                     * @private
                     * @method _initializeScope
                     */
                    var _initializeScope = function() {
                        spinnerAPI.start("top-loading-spinner");

                        var allowedPageSizes = [10, 20, 50, 100];
                        var pageSize = _closestValidPageSize( allowedPageSizes, $location.search().page_size ) || 20;

                        $scope.list = {
                            original: undefined,
                            filtered: undefined,
                            invalidCount: 0,
                            nonFatalErrors: [],

                            needsFiltering: false,
                            needsPagination: false,

                            // This will also house the properties/values from initialMeta after the first filter is
                            // complete, but filling those values in now will cause Angular UI Bootstrap to reset them
                            // to defaults since they will be considered out of range. AUIB still binds to non-existent
                            // properties on this object and we will just update those values afterward.
                            meta: {
                                allowedSizes: allowedPageSizes,
                            },

                            initialMeta: {
                                pageNumber: $location.search().page_number || 1, // Angular UI Bootstrap will handle any values out of range
                                pageSize: pageSize,                              // TODO: Retrieve from NVData
                                filterValue: $location.search().filter_value,
                            },
                        };

                        $scope.ui = {
                            isRefreshing: true,
                            fetchHasFailed: false,
                        };

                        instancesApi.get().then(function(data) {
                            $scope.list.original = data.instances;
                            $scope.list.invalidCount = data.invalidCount;
                            $scope.list.nonFatalErrors = data.nonFatalErrors;
                        }).catch(function(error) {
                            _fetchError(error);
                        });

                    };

                    // Get the page bootstrapped.
                    _initializeScope();

                    /**
                     * Helper function to ensure that the pageSize provided by the query string matches
                     * an accepted value. If not, it will pick the closest, rounding down.
                     *
                     * @method _closestValidPageSize
                     * @private
                     */
                    function _closestValidPageSize(allowedPageSizes, targetSize) {
                        targetSize = parseInt(targetSize, 10);
                        if( isNaN(targetSize) ) {
                            return;
                        }

                        var index = _.sortedIndex(allowedPageSizes, targetSize);
                        if( index >= allowedPageSizes.length ) {
                            index = allowedPageSizes.length - 1;
                        }

                        return allowedPageSizes[ index ];
                    }

                    /**
                     * Select an instance and navigate to its management view.
                     *
                     * @method selectInstance
                     * @scope
                     * @param  {Instance} instance   The instance to be selected.
                     */
                    $scope.selectInstance = function(instance) {
                        $scope.loadView("/manage/" + window.encodeURIComponent(instance.id));
                    };

                    /**
                     * Updates the query string with the meta values that aren't saved in NVData.
                     * This will basically always include the page_number and page_size.
                     *
                     * @method _saveSearchQuery
                     * @private
                     */
                    function _saveSearchQuery() {

                        // Skip this if we haven't actually filtered and set the meta properties yet.
                        // This isn't strictly required, but no sense spending the effort.
                        if( $scope.list.initialMeta ) {
                            return;
                        }

                        // Set the query args, if any. Null values remove that parameter from the search query string.
                        $location.search({
                            page_number: $scope.list.meta.pageNumber || null,
                            filter_value: $scope.list.meta.filterValue || null,
                            page_size: $scope.list.meta.pageSize || null,
                        });
                    }

                    /**
                     * Filter the instances based on the filter settings and then update the UI with
                     * newly paginated results.
                     *
                     * @method filterInstances
                     * @scope
                     */
                    $scope.filterInstances = function() {
                        $scope.list.needsFiltering = true;
                        $scope.list.needsPagination = true;
                    };

                    /**
                     * Refresh the instances list from the server.
                     *
                     * @method refreshInstances
                     * @scope
                     */
                    $scope.refreshInstances = function() {
                        spinnerAPI.start("top-loading-spinner");
                        $scope.ui.isRefreshing = true;
                        $scope.ui.fetchHasFailed = false;

                        instancesApi.fetch().then(function(data) {
                            $scope.list.original = data.instances; // Triggers filters again
                            $scope.list.invalidCount = data.invalidCount;
                            $scope.list.nonFatalErrors = data.nonFatalErrors;
                        }).catch(function(error) {
                            _fetchError(error);
                        }).finally(function() {
                            $scope.ui.isRefreshing = false;
                        });
                    };

                    /**
                     * Issue a growl error and place an error message in the instance list area.
                     */
                    function _fetchError(error) {
                        if(error) {
                            growl.error( error );
                        }
                        else {
                            growl.error(
                                LOCALE.maketext("The system failed to retrieve the list of your [asis,WordPress] installations from the server.")
                            );
                        }

                        $scope.doneRendering();
                        $scope.ui.fetchHasFailed = true;
                    }

                    /**
                     * Generate the paginated list of instances and attach it to the view.
                     *
                     * @private
                     * @method _paginateAndFilter
                     * @param {Boolean} needsFiltering   If true, the original list will be filtered again before it's paginated.
                     */
                    function _paginateAndFilter(needsFiltering) {

                        if (!$scope.list.original) {
                            return;
                        }

                        spinnerAPI.start("top-loading-spinner");

                        // Run this in a separate cycle so the browser can actually start
                        // the spinner in the UI while the rest of this is processing.
                        $timeout(function() {

                            var filteredList = needsFiltering ?
                                _filterInstances() : $scope.list.filtered || _filterInstances();

                            if(!filteredList) {
                                return; // We're not ready to update the UI
                            }

                            var oldPagedList = $scope.list.paged;
                            var newPagedList = _getCurrentPage(filteredList, $scope.list.meta);

                            // Attach lists to the view
                            $scope.list.filtered = filteredList;
                            $scope.list.paged = newPagedList;

                            if(_listIsUnchanged(oldPagedList, newPagedList) || !newPagedList.length) {
                                $timeout(function() {
                                    $scope.doneRendering();
                                });
                            }

                            // Hide the initial loading panel if it's still showing
                            $scope.hideViewLoadingPanel();
                            $scope.ui.isRefreshing = false;

                        });
                    }

                    /**
                     * Get the subset of an array pertaining to the current page.
                     *
                     * @method  _getCurrentPage
                     * @private
                     * @param  {Array}  source     Array of items to be paged.
                     * @param  {Object} options    The pagination options.
                     * @param  {Number} options.pageNumber   The current page number.
                     * @param  {Number} options.pageSize     The size of the pages.
                     * @return {Array}             An array with just the current page's items.
                     */
                    function _getCurrentPage(source, options) {
                        var startIndex = options.pageSize * (options.pageNumber - 1);
                        var endIndex   = options.pageSize * options.pageNumber;

                        if (endIndex > source.length) {
                            endIndex = source.length;
                        }

                        return (source.length < options.pageSize) ?
                            source.slice():
                            source.slice(startIndex, endIndex);
                    }


                    /**
                     * Comparison to check if the oldList and newList are the same.
                     *
                     * @method  _listIsUnchanged
                     * @private
                     * @param  {Array} oldList List of objects from the previous filter or pagination.
                     * @param  {Array} newList List of objects from the current  filter or pagination.
                     * @return {Boolean}       true if the lists are equivalent, false otherwise.
                     */
                    function _listIsUnchanged(oldList, newList) {
                        if(!oldList || !newList || oldList.length !== newList.length) {
                            return false;
                        }

                        return oldList.every(function(oldInstance, index) {
                            var newInstance = newList[ index ];
                            return (newInstance === oldInstance) || _.isEqual(newInstance, oldInstance);
                        });
                    }

                    /**
                     * Filter instances based on the various filters.
                     *
                     * @method  _filterInstances
                     * @return {Array} List of instances that match the various filters.
                     *                 Returns undefined if the filters or data aren't ready yet.
                     */
                    function _filterInstances() {
                        if(!$scope.list.original) {
                            // We're not ready for filtering yet
                            return;
                        }

                        // Set the meta-data using the initialMeta if it's the first run
                        if($scope.list.initialMeta) {
                            angular.forEach($scope.list.initialMeta, function(val, key) {
                                $scope.list.meta[key] = val;
                            });
                            delete $scope.list.initialMeta;
                        }

                        var filteredList = $scope.list.original;

                        // Filter the search term first
                        filteredList = filteredList.filter( _filterByValue );

                        return filteredList;
                    }

                    /**
                     * Filter method to test if the instance should be filtered by a string value.
                     *
                     * @method _filterByValue
                     * @param  {Object} instance   The instance to be tested.
                     * @return {Boolean}           true if the instance should be included, false otherwise.
                     */
                    function _filterByValue(instance) {
                        if(!$scope.list.meta.filterValue) {
                            return true;
                        }

                        return [
                            "domain",
                            "full_path",
                        ].some(function(key) {
                            var propVal = instance[key];
                            if(propVal && propVal.toLocaleLowerCase().indexOf($scope.list.meta.filterValue) !== -1) {
                                return true;
                            }
                            return false;
                        });
                    }

                    /**
                     * Clears the search term when the Esc key is pressed.
                     *
                     * @method triggerClearSearch
                     * @scope
                     * @param {Event} event   The event object
                     */
                    $scope.triggerClearSearch = function(event) {
                        if (event.keyCode === 27) {
                            $scope.clearSearch();
                        }
                    };

                    /**
                     * Clears the search term.
                     *
                     * @method clearSearch
                     * @scope
                     */
                    $scope.clearSearch = function() {
                        $scope.list.meta.filterValue = "";
                        $scope.filterInstances();
                    };

                    /**
                     * Called when the last row is inserted to stop the loading spinner.
                     *
                     * @method doneRendering
                     * @scope
                     * @param [{Object}] user   Not required. Just for debugging
                     */
                    $scope.doneRendering = function(user) {
                        spinnerAPI.stop("top-loading-spinner");
                        $scope.hideViewLoadingPanel();
                        $scope.ui.isRefreshing = false;
                    };

                    $scope.$watchGroup(["list.meta.pageSize", "list.meta.pageNumber"], function(newVals) {

                        // If the pageSize is undefined, then this is the
                        // initial watch, so we can skip processing for now.
                        if(angular.isUndefined(newVals[0]) || $scope.list.initialMeta) {
                            return;
                        }

                        $scope.scrollTo("top");
                        _saveSearchQuery();
                        $scope.list.needsPagination = true;
                    });

                    $scope.$watch("list.meta.filterValue", function(newVal, oldVal) {
                        if(newVal !== oldVal) {
                            _saveSearchQuery();
                            $scope.list.needsFiltering = true;
                        }
                    });

                    $scope.$watchGroup(["list.needsFiltering", "list.needsPagination"], function(needs) {
                        var needsFiltering = needs[0];
                        var needsPagination = needs[1];

                        if(needsPagination || needsFiltering) {
                            _paginateAndFilter(needsFiltering);
                            $scope.list.needsFiltering = false;
                            $scope.list.needsPagination = false;
                        }
                    });

                    /**
                     * This is a basic watch using === for simplicity and watch performance, so you
                     * should never alter list.original in place. Always set it to a new array.
                     */
                    $scope.$watch("list.original", function(newVal, oldVal) {
                        if(!newVal) {
                            return;
                        }

                        $scope.filterInstances();

                        if($scope.list.invalidCount) {
                            growl.warning(
                                LOCALE.maketext("[_1] [asis,WordPress] [numerate,_1,installation is,installations are] not included due to data errors.", $scope.list.invalidCount)
                            );
                        }

                        $scope.list.nonFatalErrors.forEach(function(error) {
                            growl.warning(
                                LOCALE.maketext("The system could not display some of your [asis,WordPress] installations due to loading errors: [_1]", error)
                            );
                        });
                    });

                }
            ]
        );

        return controller;
    }
);

/*
 * wordpress/util/versionComparison.js                        Copyright 2017 cPanel, Inc.
 *                                                                   All rights Reserved.
 * copyright@cpanel.net                                                 http://cpanel.net
 * This code is subject to the cPanel license. Unauthorized copying isiteviews prohibited
 */

/* global define: false */

/**
 * TODO: Port to cjt2/util once we merge with the main product since this has general utility.
 */

define('app/util/versionComparison',[
    "cjt/util/locale",
], function(LOCALE) {

    /**
     * @method  versionCompare
     * @source Derived from: https://gist.github.com/TheDistantSea/8021359
     * @reference http://stackoverflow.com/questions/6832596/how-to-compare-software-version-number-using-js-only-number
     * @param  {String} v1
     * @param  {String} v2
     * @param  {Object} options
     *   @param {Boolean} [options.lexicographical]
     *   @param {Boolean} [options.zeroExtend]
     * @return {Number}
     */
    function versionCompare(v1, v2, options) {

        // Validate the inputs
        if (typeof(v1) === "undefined" ||
            typeof(v2) === "undefined" ||
            typeof(v1) !== "string" ||
            typeof(v2) !== "string") {
            throw new Error(LOCALE.maketext("You must pass two string arguments to the version comparison."));
        }

        if (v1 === "" || v2 === "") {
            throw new Error(LOCALE.maketext("You must pass two defined string arguments to the version comparison. These usually resemble a form similar to: 1.0.0.1."));
        }

        var lexicographical = options && options.lexicographical,
            zeroExtend = options && options.zeroExtend,
            v1parts = v1.split("."),
            v2parts = v2.split(".");

        /**
         * Helper function to validate the phrases in a version.
         * A phrase is any section of a version where sections are
         * separated by periods: [.].
         *
         * @name isValidPhrase
         * @private
         * @param  {String}  phrase
         * @return {Boolean}
         */
        function isValidPhrase(phrase) {
            return (lexicographical ?
                        /^\d+[A-Za-z0-9_-]*$/ :
                        /^\d+$/)
                    .test(phrase);
        }

        if (!v1parts.every(isValidPhrase) ||
            !v2parts.every(isValidPhrase)) {
            return NaN;
        }

        if (zeroExtend) {
            while (v1parts.length < v2parts.length) {
                v1parts.push("0");
            }
            while (v2parts.length < v1parts.length) {
                v2parts.push("0");
            }
        }

        if (!lexicographical) {
            v1parts = v1parts.map(Number);
            v2parts = v2parts.map(Number);
        }

        for (var i = 0; i < v1parts.length; ++i) {
            if (v2parts.length === i) {
                return 1;
            }

            if (v1parts[i] === v2parts[i]) {
                continue;
            }
            else if (v1parts[i] > v2parts[i]) {
                return 1;
            }
            else {
                return -1;
            }
        }

        if (v1parts.length !== v2parts.length) {
            return -1;
        }

        return 0;
    }

    return versionCompare;
});

/* wordpress/util/versionCheck.js                             Copyright 2017 cPanel, Inc.
 *                                                                   All rights Reserved.
 * copyright@cpanel.net                                                 http://cpanel.net
 * This code is subject to the cPanel license. Unauthorized copying isiteviews prohibited
 */

/* global define: false */

/**
 * NOTES:
 *   1) These rules are derived from the wordpress.org description of major
 *   and minor updates described here:
 *
 *   https://make.wordpress.org/core/handbook/about/release-cycle/version-numbering/
 */

define('app/util/versionCheck',[
    "cjt/util/locale",
    "lodash"
], function(LOCALE, _) {

    /**
     * Checks if the upgrade between two version is a major upgrade.
     * Note, if v2 is not an upgrade to v1 then the function returns false.
     *
     * We will assume the the first 2 digits always exist in the version
     * number.
     *
     * @method  isMajorUpgrade
     * @param  {String} v1
     * @param  {String} v2
     * @return {Boolean}
     */
    function isMajorUpgrade(v1, v2) {

        // Validate the inputs
        if (_.isUndefined(v1) ||
            _.isUndefined(v2) ||
            typeof(v1) !== "string" ||
            typeof(v2) !== "string") {
            throw new Error(LOCALE.maketext("You must pass two string arguments to the version comparison."));
        }

        if (v1 === "" || v2 === "") {
            throw new Error(LOCALE.maketext("You must pass two defined string arguments to the version comparison. These usually resemble a form similar to: 1.0.0.1."));
        }

        if (v1 === v2) {
            return false;
        }

        var v1Parts = v1.split(/[.]/);
        var v2Parts = v2.split(/[.]/);

        // 1 => 2 (1.?.? => 2.0.0)  // major upgrade
        // 1 => 1.1 (1.0 => 1.1)    // major upgrade
        if ((v1Parts[0] < v2Parts[0]) ||
            (v1Parts[0] === v2Parts[0] && v1Parts[1] < v2Parts[1])) {
            return true;
        }
        return false;
    }

    /**
     * Checks if the upgrade between two version is a minor upgrade.
     * Note, if v2 is not an upgrade to v1 then the function returns false.
     *
     * The third digit in the version may or may not be present. A missing
     * digit is assumed to be 0.
     *
     * @method  isMinorUpgrade
     * @param  {String} v1
     * @param  {String} v2
     * @return {Boolean}
     */
    function isMinorUpgrade(v1, v2) {

        // Validate the inputs
        if (typeof(v1) === "undefined" ||
            typeof(v2) === "undefined" ||
            typeof(v1) !== "string" ||
            typeof(v2) !== "string") {
            throw new Error(LOCALE.maketext("You must pass two string arguments to the version comparison."));
        }

        if (v1 === "" || v2 === "") {
            throw new Error(LOCALE.maketext("You must pass two defined string arguments to the version comparison. These usually resemble a form similar to: 1.0.0.1."));
        }

        if (v1 === v2) {
            return false;
        }

        var v1Parts = v1.split(/[.]/);
        var v2Parts = v2.split(/[.]/);

        // Auto extend the 0s
        if (v1Parts.length === 2) {
            v1Parts.push("0");
        }
        if (v2Parts.length === 2) {
            v2Parts.push("0");
        }

        if (v1Parts[0] === v2Parts[0] && v1Parts[1] === v2Parts[1]) {
            return v1Parts[2] < v2Parts[2];
        }
        return false;
    }

    return {
        isMajorUpgrade: isMajorUpgrade,
        isMinorUpgrade: isMinorUpgrade,
    };
});

/*
 * wordpress/directives/changePassword.js             Copyright 2017 cPanel, Inc.
 *                                                           All rights Reserved.
 * copyright@cpanel.net                                         http://cpanel.net
 * This code is subject to the cPanel license. Unauthorized copying is prohibited
 */

/* global define: false */

define('app/directives/changePassword',[
    "angular",
    "cjt/core",
    "cjt/util/test",
    "cjt/directives/actionButtonDirective",
    "cjt/directives/passwordFieldDirective",
    "cjt/directives/validationContainerDirective",
    "cjt/directives/validationItemDirective",
    "cjt/directives/validateEqualsDirective",
], function(
    angular,
    CJT,
    TEST
) {
    var BASE_RELATIVE_PATH = "wordpress/directives/changePassword.ptt";

    /**
     * An individual instance in the list of instances on the selction screen.
     */

    angular.module("cpanel.wordpress").directive("changePassword", function() {

        var ChangePassword = function() {
            this.model = "";
            this.confirmModel = "";
            this.isUpdating = false;
        };

        angular.extend(ChangePassword.prototype, {
            /**
             * Wrap the provided submit handler so that we can disable the submission button
             * if we're performing an async action.
             *
             * @method submitUpdate
             * @return Promise
             */
            submitUpdate: function() {
                var result =  this._submitUpdate({ newPass: this.model });

                if( TEST.isQPromise(result) ) {
                    this.isUpdating = true;
                    return result.finally(function() {
                        this.isUpdating = false;
                    }.bind(this));
                }
            }
        });

        return {
            templateUrl: BASE_RELATIVE_PATH, // This template is included in index.html.tt, so no need to build the full path for debug mode
            restrict: "E",
            controllerAs: "password",
            bindToController: true,
            scope: {
                name: "@",
                _submitUpdate: "&onSubmit",
                _cancelUpdate: "&onCancel",
                passwordLabel: "@",
                passwordConfirmLabel: "@",
            },
            controller: ChangePassword,
            link: function(scope, elem) {

                // The main password input won't exist until the post-link
                // phase, so the initial focus action needs to go here.
                var input = elem[0] && elem[0].querySelector(".password-input-container input");
                if(input) {
                    input.focus();
                }
            }
        };
    });
});
/*
 * wordpress/directives/urlInputDirective.js          Copyright 2017 cPanel, Inc.
 *                                                           All rights Reserved.
 * copyright@cpanel.net                                         http://cpanel.net
 * This code is subject to the cPanel license. Unauthorized copying is prohibited
 */

/* global define: false */

define('app/directives/urlInputDirective',[
    "angular",
    "cjt/core",
], function(
    angular,
    CJT
) {
    var APP_RELATIVE_PATH = "directives/urlInputDirective.ptt";
    var BASE_RELATIVE_PATH = "wordpress/" + APP_RELATIVE_PATH;

    /**
     * An individual instance in the list of instances on the selction screen.
     */

    angular.module("cpanel.wordpress").directive("urlInput", function() {

        return {
            restrict: "E",
            scope: {
                readonly: "=",
                disabled: "=",
                name:     "=",
                id:       "=",
                domains:  "=",
            },
            require: "ngModel",
            templateUrl: CJT.config.debug ? CJT.buildFullPath(BASE_RELATIVE_PATH) : BASE_RELATIVE_PATH,
            link: function(scope, element, attrs, ngModelCtrl) {

                // Handle conversion of "true" | "false" into booleans
                attrs.$observe("readonly", function() {
                    scope.readonly = scope.$eval(attrs.readonly);
                    if (scope.readonly === undefined) {
                        delete scope.readonly;
                    }
                });

                // Handle conversion of "true" | "false" into booleans
                attrs.$observe("disabled", function() {
                    scope.disabled = scope.$eval(attrs.disabled);
                    if (scope.disabled === undefined) {
                        delete scope.disabled;
                    }
                });

                // Setup the ngModel for the url to url parts conversion
                // Note:
                //  1) protocol is optional. if provided it will render in
                //     a leading fixed decoration.
                //  2) path is optional. if not provided, it will just be
                //     an empty input in the directive output.
                ngModelCtrl.$formatters.push(function(url) {
                    var parts;
                    if(url) {
                        parts = url.split("/");
                    }

                    if (!parts || !parts.length) {
                        return {
                            protocol: "",
                            domain:   "",
                            path:     "",
                        };
                    }
                    else if (parts[0].match(/:\/$/)) {
                        return {
                            protocol: parts && parts.length ? parts.shift() + "/" : "",
                            domain:   parts && parts.length ? parts.shift() : "",
                            path:     parts && parts.length ? parts.join("/") : "",
                        };
                    } else {
                        return {
                            protocol: "",
                            domain:   parts && parts.length ? parts.shift() : "",
                            path:     parts && parts.length ? parts.join("/") : "",
                        };
                    }
                });

                ngModelCtrl.$parsers.push(function(val){
                    return val.protocol + val.domain + "/" + val.path;
                });

                ngModelCtrl.$render = function() {
                    scope.protocol = ngModelCtrl.$viewValue.protocol;
                    scope.domain   = ngModelCtrl.$viewValue.domain;
                    scope.path     = ngModelCtrl.$viewValue.path;
                };

                scope.$watch("scope.protocol + scope.domain + scope.path", function() {
                    ngModelCtrl.$setViewValue({
                        protocol: scope.protocol,
                        domain:   scope.domain,
                        path:     scope.path,
                    });
                });
            }
        };
    });
});
/*
 * wordpress/views/manageSiteController.js                    Copyright 2017 cPanel, Inc.
 *                                                                   All rights Reserved.
 * copyright@cpanel.net                                                 http://cpanel.net
 * This code is subject to the cPanel license. Unauthorized copying isiteviews prohibited
 */

/* global define: false */

define(
    'app/views/manageSiteController',[
        "angular",
        "cjt/util/locale",
        "app/util/versionComparison",
        "app/util/versionCheck",
        "uiBootstrap",

        "cjt/services/alertService",
        "cjt/directives/alertList",
        "cjt/directives/toggleSwitchDirective",

        "app/services/instancesApi",
        "app/directives/changePassword",
        "app/directives/urlInputDirective",
    ],
    function(angular, LOCALE, compare, CHECKS) {

        // Retrieve the current application
        var app = angular.module("cpanel.wordpress");

        // Setup the controller
        var controller = app.controller(
            "manageSiteController", [
                "$scope",
                "$timeout",
                "$routeParams",
                "$location",
                "growl",
                "instancesApi",
                "alertService",
                function(
                    $scope,
                    $timeout,
                    $routeParams,
                    $location,
                    growl,
                    instancesApi,
                    alertService
                ) {

                    /**
                     * Initialize the scope variables
                     *
                     * @method _initializeScope
                     * @private
                     */
                    var _initializeScope = function() {
                        $scope.site = {
                            id: window.decodeURIComponent( $routeParams.id ),
                        };
                        $scope.ui = {
                            showAdvanced: false,
                            isRefreshing: false,
                            viewDoneLoading: false,
                            showChangeAdminPassword: false,
                            showChangeDbPassword: false,
                            selectedAdminUsername: undefined,
                        };
                        $scope.getInstanceInfo();
                    };

                    /**
                     * Initialize the view
                     *
                     * @method _initializeView
                     * @private
                     */
                    var _initializeView = function() {
                        alertService.clear(void 0, "adminPassword");
                        alertService.clear(void 0, "dbPassword");
                    };

                    /**
                     * Get an instance object from a site ID if the list is cached. No
                     * fetching for now because this is just an early implementation.
                     *
                     * @method getInstanceInfo
                     * @scope
                     */
                    $scope.getInstanceInfo = function() {
                        if($scope.site.id) {
                            $scope.instanceLoadError = null;
                            $scope.ui.isRefreshing = true;
                            return instancesApi.getById({ id: $scope.site.id, force: true })
                                .then(
                                    function(instance){
                                        $scope.ui.invalidInstance = !instance || !Object.keys(instance).length;
                                        if(!$scope.ui.invalidInstance) {
                                            $scope.site    = instance;
                                            if( instance.admins && instance.admins.length === 1) {
                                                $scope.ui.selectedAdminUsername = instance.admins[0].user_login;
                                            }

                                            /* A load that's successful overall can still produce a partial failure
                                             * that we want to display to the user, but this is not enough for us to
                                             * set invalidInstance, which would hide the entire page body. */
                                            if(instance.error){
                                                $scope.instanceLoadError = instance.error;
                                            }

                                            $scope.ui.minor_updates_only = ($scope.site["autoupdate.core.minor"] && !$scope.site["autoupdate.core.major"]);
                                            $scope.ui.all_updates        = ($scope.site["autoupdate.core.minor"] &&  $scope.site["autoupdate.core.major"]);
                                        }
                                    },
                                    function(error){
                                        $scope.instanceLoadError = error;
                                        $scope.ui.invalidInstance = true;
                                    }
                                ).finally(function() {
                                    $scope.ui.isRefreshing = false;
                                    $scope.ui.viewDoneLoading = true;
                                });
                        }
                    };

                    /**
                     * Fetches the current version or a message if unknown.
                     *
                     * @method  getCurrentVersionText description
                     * @scope
                     * @param  {Object} site Site configuration data
                     *   @param {String} site.current_version Version string from the backend.
                     * @return {String}
                     */
                    $scope.getCurrentVersionText = function(site) {
                        if (site.current_version) {
                            return site.current_version;
                        } else {
                            return LOCALE.maketext("Unknown");
                        }
                    };

                    /**
                     * Fetches the auto update text based on the data
                     * provided in the passed site configuration.
                     *
                     * @method getAutoupdateText
                     * @scope
                     * @param  {Object} site Site configuration data
                     *   @param {Boolean} site.autoupdate True if core autoupdates are enabled, false otherwise.
                     * @return {String}
                     */
                    $scope.getAutoupdateText = function(site) {
                        if (site.autoupdate) {
                            if (site["autoupdate.core.minor"] && site["autoupdate.core.major"]) {
                                return LOCALE.maketext("Enabled (Major Versions, Minor Versions, and Security Updates)");
                            } else if (site["autoupdate.core.minor"]) {
                                return LOCALE.maketext("Enabled (Minor Versions and Security Updates)");
                            } else {
                                return LOCALE.maketext("Enabled (Major Versions)");
                            }
                        } else if ("autoupdate" in site){
                            return LOCALE.maketext("Disabled");
                        } else {
                            return LOCALE.maketext("Unknown");
                        }
                    };

                    /**
                     * Toggle the advanced setting section.
                     *
                     * @method toggleAdvanced
                     * @scope
                     */
                    $scope.toggleAdvanced = function() {
                        $scope.ui.showAdvanced = !$scope.ui.showAdvanced;
                    };

                    /**
                     * Toggle the display of additional error detail.
                     *
                     * @method toggleErrorDetail
                     * @scope
                     */
                    $scope.toggleErrorDetail = function() {
                        $scope.ui.showErrorDetail = !$scope.ui.showErrorDetail;
                    };

                    /**
                     * Toggle "minor updates only" for a WordPress site. If major updates are already enabled, they will
                     * be disabled as part of this operation.
                     *
                     * @method toggleMinorUpdatesOnly
                     * @scope
                     */
                    $scope.toggleMinorUpdatesOnly = function(site) {
                        var original = { site: {}, ui: {} };
                        original["site"]["autoupdate.core.minor"] = site["autoupdate.core.minor"];
                        original["site"]["autoupdate.core.major"] = site["autoupdate.core.major"];
                        original.ui.minor_updates_only = $scope.ui.minor_updates_only;
                        original.ui.all_updates = $scope.ui.all_updates;

                        $scope.ui.minor_updates_only = !$scope.ui.minor_updates_only;
                        if ($scope.ui.minor_updates_only){
                            $scope.ui.all_updates = false;
                        }

                        site["autoupdate.core.minor"] = ($scope.ui.minor_updates_only || $scope.ui.all_updates);
                        site["autoupdate.core.major"] = $scope.ui.all_updates;

                        return instancesApi.configureAutoupdate($scope.site.id, site["autoupdate.core.major"], site["autoupdate.core.minor"]).then(
                            function(updatedInstance){
                                if(updatedInstance) {
                                    $location.path("manage/" + updatedInstance.id);
                                    $location.replace();
                                }
                                alertService.clear(undefined, "autoUpdate");
                            }, function(error){
                                site["autoupdate.core.minor"] = original["site"]["autoupdate.core.minor"];
                                site["autoupdate.core.major"] = original["site"]["autoupdate.core.major"];
                                $scope.ui.minor_updates_only = original.ui.minor_updates_only;
                                $scope.ui.all_updates = original.ui.all_updates;

                                alertService.add({
                                    id: "toggle-minor-updates-error",
                                    group: "autoUpdate",
                                    type: "danger",
                                    replace: true,
                                    message: LOCALE.maketext(
                                        "The system failed to change the Automatic Update settings: [_1]",
                                        error
                                    ),
                                });
                            }
                        );
                    };

                    /**
                     * Toggle "all updates" for a WordPress site. This includes major updates. If the "minor updates only"
                     * control is already enabled, it will be disabled as part of this operation, since the two are
                     * mutually exclusive.
                     *
                     * @method toggleAllUpdates
                     * @scope
                     */
                    $scope.toggleAllUpdates = function(site) {
                        var original = { site: {}, ui: {} };
                        original["site"]["autoupdate.core.minor"] = site["autoupdate.core.minor"];
                        original["site"]["autoupdate.core.major"] = site["autoupdate.core.major"];
                        original.ui.minor_updates_only = $scope.ui.minor_updates_only;
                        original.ui.all_updates = $scope.ui.all_updates;

                        $scope.ui.all_updates = !$scope.ui.all_updates;
                        if ($scope.ui.all_updates){
                            $scope.ui.minor_updates_only = false;
                        }

                        site["autoupdate.core.minor"] = ($scope.ui.minor_updates_only || $scope.ui.all_updates);
                        site["autoupdate.core.major"] = $scope.ui.all_updates;

                        return instancesApi.configureAutoupdate($scope.site.id, site["autoupdate.core.major"], site["autoupdate.core.minor"]).then(
                            function(updatedInstance){
                                if(updatedInstance) {
                                    $location.path("manage/" + updatedInstance.id);
                                    $location.replace();
                                }
                                alertService.clear(undefined, "autoUpdate");
                            },
                            function(error){
                                site["autoupdate.core.minor"] = original["site"]["autoupdate.core.minor"];
                                site["autoupdate.core.major"] = original["site"]["autoupdate.core.major"];
                                $scope.ui.minor_updates_only = original.ui.minor_updates_only;
                                $scope.ui.all_updates = original.ui.all_updates;

                                alertService.add({
                                    id: "toggle-minor-updates-error",
                                    group: "autoUpdate",
                                    type: "danger",
                                    replace: true,
                                    message: LOCALE.maketext(
                                        "The system failed to change the Automatic Update settings: [_1]",
                                        error
                                    ),
                                });
                            }
                        );
                    };

                    /**
                     * Show the password field for the WordPress admin. This field is hidden by
                     * default so that it's clear to the user that it doesn't need to be filled out
                     * when making any other changes.
                     *
                     * @method showChangeAdminPassword
                     * @scope
                     */
                    $scope.showChangeAdminPassword = function() {
                        alertService.clear(undefined, "adminPassword");
                        $scope.ui.showChangeAdminPassword = true;
                    };

                    /**
                     * Hide the password field for the WordPress admin.
                     * @method hideChangeAdminPassword
                     * @scope
                     */
                    $scope.hideChangeAdminPassword = function() {
                        $scope.ui.showChangeAdminPassword = false;
                    };

                    /**
                     * Change the WordPress admin password.
                     *
                     * @method changeAdminPassword
                     * @scope
                     * @param {String} newPass   The user's new password.
                     */
                    $scope.changeAdminPassword = function(newPass) {

                        var username = $scope.ui.selectedAdminUsername;

                        return instancesApi.changeUserPassword( $scope.site.id, username, newPass ).then(
                            function() {
                                alertService.add({
                                    id: "change-admin-pass-success",
                                    group: "adminPassword",
                                    type: "success",
                                    replace: true,
                                    message: LOCALE.maketext(
                                        "The system succesfully changed the [asis,WordPress] password for “[_1]”.",
                                        username
                                    ),
                                });
                            },
                            function(error) {
                                alertService.add({
                                    id: "change-admin-pass-error",
                                    group: "adminPassword",
                                    type: "danger",
                                    replace: true,
                                    message: LOCALE.maketext(
                                        "The system failed to change the [asis,WordPress] password for “[_1]” with the following error: [_2]",
                                        username,
                                        error
                                    ),
                                });
                            }
                        ).finally(
                            function() {
                                $scope.hideChangeAdminPassword();
                            }
                        );
                    };

                    /**
                     * Show the password field for the WordPress database. This field is hidden by
                     * default so that it's clear to the user that it doesn't need to be filled out
                     * when making any other changes.
                     *
                     * @method showChangeDbPassword
                     * @scope
                     */
                    $scope.showChangeDbPassword = function() {
                        alertService.clear(undefined, "dbPassword");
                        $scope.ui.showChangeDbPassword = true;
                    };

                    /**
                     * Hide the password field for the WordPress db.
                     * @method hideChangeDbPassword
                     * @scope
                     */
                    $scope.hideChangeDbPassword = function() {
                        $scope.ui.showChangeDbPassword = false;
                    };

                    /**
                     * Change the WordPress database password.
                     *
                     * @method changeDbPassword
                     * @scope
                     */
                    $scope.changeDbPassword = function(newPass) {

                        return instancesApi.changeDbPassword( $scope.site.id, newPass ).then(
                            function() {
                                alertService.add({
                                    id: "change-db-pass-success",
                                    group: "dbPassword",
                                    type: "success",
                                    replace: true,
                                    message: LOCALE.maketext("The system succesfully changed the [asis,WordPress] database user’s password."),
                                });
                            },
                            function(error) {
                                alertService.add({
                                    id: "change-db-pass-error",
                                    group: "dbPassword",
                                    type: "danger",
                                    replace: true,
                                    message: LOCALE.maketext("The system failed to change the [asis,WordPress] database password with the following error: [_1]", error),
                                });
                            }
                        ).finally(
                            function() {
                                $scope.hideChangeDbPassword();
                            }
                        );
                    };

                    /**
                     * Check if the current version is less than the available version.
                     * When the available version if greater then the current version, the
                     * method returns true, otherwise it returns false.
                     *
                     * @method isCurrentVersionOutOfDate
                     * @param  {Object}  site
                     * @param {String} [site.current_version]   Current version string.
                     * @param {String} [site.available_version] Available version string.
                     * @return {Boolean}  true when the current version needs to be updated.
                     */
                    $scope.isCurrentVersionOutOfDate = function(site) {
                        return site.available_version && site.current_version && compare(site.available_version, site.current_version) === 1;
                    };

                    /**
                     * Check if the site has a major upgrade available
                     *
                     * @method  hasMajorUpgrade
                     * @scope
                     * @param  {Object}  site Site information returned by the api.
                     * @return {Boolean}      true if the site has a major upgrade available, false otherwise.
                     */
                    $scope.hasMajorUpgrade = function(site) {
                        return CHECKS.isMajorUpgrade(site.current_version, site.available_version);
                    };

                    /**
                     * Check if the site has a minor upgrade available
                     *
                     * @method  hasMinorUpgrade
                     * @scope
                     * @param  {Object}  site Site information returned by the api.
                     * @return {Boolean}      true if the site has a major upgrade available, false otherwise.
                     */
                    $scope.hasMinorUpgrade = function(site) {
                        return CHECKS.isMinorUpgrade(site.current_version, site.available_version);
                    };

                    /**
                     * Check if the autoupdater will attempt to update an upgrade.
                     *
                     * @method  willCurrentVersionAutoUpdate
                     * @param  {Object} site Site information returned by the api.
                     * @return {Boolean}     true if the autoupdate is set to upgrade the specific upgrade.
                     */
                    $scope.willCurrentVersionAutoUpdate = function(site) {
                        var hasMajor = $scope.hasMajorUpgrade(site);
                        var hasMinor = $scope.hasMinorUpgrade(site);

                        if (hasMajor && site["autoupdate.core.major"]) {
                            return true;
                        } else if (hasMinor && site["autoupdate.core.minor"]) {
                            return true;
                        }
                        return false;
                    };

                    /**
                     * Whether or not to show the warning box about legacy instances getting updates through
                     * the cPAddons system rather than WordPress itself. In the common case, this will just
                     * be shown for legacy addons and hidden for non-legacy, but there is also a special case
                     * for legacy addons that have been tweaked to self-update. These ones should not show the
                     * warning.
                     *
                     * @method shouldShowLegacyUpdatesInfo
                     * @scope
                     * @param {Object}   site
                     * @param  {String}  site.addon_type One of: modern, legacy, other.
                     * @return {Boolean} True if the warning should be shown; false otherwise.
                     */
                    $scope.shouldShowLegacyUpdatesInfo = function(site) {
                        return site.addon_type === "legacy" && !site.autoupdate;
                    };

                    // Get the page bootstrapped.
                    _initializeScope();
                    _initializeView();
                }
            ]
        );

        return controller;
    }
);

/*
 * wordpress/index.js                                 Copyright 2017 cPanel, Inc.
 *                                                           All rights Reserved.
 * copyright@cpanel.net                                         http://cpanel.net
 * This code is subject to the cPanel license. Unauthorized copying is prohibited
 */

/* global require: false, define: false, PAGE: false */


define(
    'app/index',[
        "angular",
        "jquery",
        "cjt/core",
        "cjt/modules",
        "ngRoute",
        "uiBootstrap",
        "angular-chosen",
    ],
    function(angular, $, CJT) {
        return function() {
            // First create the application
            angular.module("cpanel.wordpress", [
                "ngRoute",
                "ui.bootstrap",
                "cjt2.cpanel",
                "angular-growl",
                "localytics.directives", // angular-chosen
            ]);

            // Then load the application dependencies
            var app = require(
                [
                    "cjt/bootstrap",
                    "cjt/decorators/growlDecorator",
                    "cjt/views/applicationController",
                    "app/views/listController",
                    "app/views/manageSiteController",
                ], function(BOOTSTRAP) {

                    var app = angular.module("cpanel.wordpress");

                    app.value("pageState", PAGE);

                    app.config([
                        "$routeProvider",
                        "$compileProvider",
                        "growlProvider",
                        function(
                            $routeProvider,
                            $compileProvider,
                            growlProvider
                        ) {

                            $routeProvider.when("/list", {
                                controller:     "listController",
                                templateUrl:    "wordpress/views/listView.ptt",
                                reloadOnSearch: false,
                            });

                            $routeProvider.when("/manage/:id", {
                                controller: "manageSiteController",
                                templateUrl: "wordpress/views/manageSiteView.ptt"
                            });

                            $routeProvider.otherwise({
                                "redirectTo": "/list"
                            });

                            growlProvider.globalTimeToLive({success: 5000, warning: 10000, info: 5000, error: -1});
                            growlProvider.globalDisableCountDown(true);
                            growlProvider.onlyUniqueMessages(false);

                            if(!CJT.config.debug) {
                                $compileProvider.debugInfoEnabled(false);
                            }
                        }
                    ]);

                    BOOTSTRAP("#content", "cpanel.wordpress");

                });

            return app;
        };
    }
);

